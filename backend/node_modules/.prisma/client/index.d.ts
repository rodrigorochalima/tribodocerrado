
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Familiar
 * 
 */
export type Familiar = $Result.DefaultSelection<Prisma.$FamiliarPayload>
/**
 * Model Premio
 * 
 */
export type Premio = $Result.DefaultSelection<Prisma.$PremioPayload>
/**
 * Model Moto
 * 
 */
export type Moto = $Result.DefaultSelection<Prisma.$MotoPayload>
/**
 * Model Evento
 * 
 */
export type Evento = $Result.DefaultSelection<Prisma.$EventoPayload>
/**
 * Model ParticipacaoEvento
 * 
 */
export type ParticipacaoEvento = $Result.DefaultSelection<Prisma.$ParticipacaoEventoPayload>
/**
 * Model ComboioEvento
 * 
 */
export type ComboioEvento = $Result.DefaultSelection<Prisma.$ComboioEventoPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserType: {
  ADMINISTRADOR: 'ADMINISTRADOR',
  DIRETOR: 'DIRETOR',
  MEMBRO: 'MEMBRO',
  VISITANTE: 'VISITANTE'
};

export type UserType = (typeof UserType)[keyof typeof UserType]

}

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.familiar`: Exposes CRUD operations for the **Familiar** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Familiars
    * const familiars = await prisma.familiar.findMany()
    * ```
    */
  get familiar(): Prisma.FamiliarDelegate<ExtArgs>;

  /**
   * `prisma.premio`: Exposes CRUD operations for the **Premio** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Premios
    * const premios = await prisma.premio.findMany()
    * ```
    */
  get premio(): Prisma.PremioDelegate<ExtArgs>;

  /**
   * `prisma.moto`: Exposes CRUD operations for the **Moto** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Motos
    * const motos = await prisma.moto.findMany()
    * ```
    */
  get moto(): Prisma.MotoDelegate<ExtArgs>;

  /**
   * `prisma.evento`: Exposes CRUD operations for the **Evento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Eventos
    * const eventos = await prisma.evento.findMany()
    * ```
    */
  get evento(): Prisma.EventoDelegate<ExtArgs>;

  /**
   * `prisma.participacaoEvento`: Exposes CRUD operations for the **ParticipacaoEvento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ParticipacaoEventos
    * const participacaoEventos = await prisma.participacaoEvento.findMany()
    * ```
    */
  get participacaoEvento(): Prisma.ParticipacaoEventoDelegate<ExtArgs>;

  /**
   * `prisma.comboioEvento`: Exposes CRUD operations for the **ComboioEvento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComboioEventos
    * const comboioEventos = await prisma.comboioEvento.findMany()
    * ```
    */
  get comboioEvento(): Prisma.ComboioEventoDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Familiar: 'Familiar',
    Premio: 'Premio',
    Moto: 'Moto',
    Evento: 'Evento',
    ParticipacaoEvento: 'ParticipacaoEvento',
    ComboioEvento: 'ComboioEvento'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "familiar" | "premio" | "moto" | "evento" | "participacaoEvento" | "comboioEvento"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Familiar: {
        payload: Prisma.$FamiliarPayload<ExtArgs>
        fields: Prisma.FamiliarFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FamiliarFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamiliarPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FamiliarFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamiliarPayload>
          }
          findFirst: {
            args: Prisma.FamiliarFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamiliarPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FamiliarFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamiliarPayload>
          }
          findMany: {
            args: Prisma.FamiliarFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamiliarPayload>[]
          }
          create: {
            args: Prisma.FamiliarCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamiliarPayload>
          }
          createMany: {
            args: Prisma.FamiliarCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FamiliarCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamiliarPayload>[]
          }
          delete: {
            args: Prisma.FamiliarDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamiliarPayload>
          }
          update: {
            args: Prisma.FamiliarUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamiliarPayload>
          }
          deleteMany: {
            args: Prisma.FamiliarDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FamiliarUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FamiliarUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FamiliarPayload>
          }
          aggregate: {
            args: Prisma.FamiliarAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFamiliar>
          }
          groupBy: {
            args: Prisma.FamiliarGroupByArgs<ExtArgs>
            result: $Utils.Optional<FamiliarGroupByOutputType>[]
          }
          count: {
            args: Prisma.FamiliarCountArgs<ExtArgs>
            result: $Utils.Optional<FamiliarCountAggregateOutputType> | number
          }
        }
      }
      Premio: {
        payload: Prisma.$PremioPayload<ExtArgs>
        fields: Prisma.PremioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PremioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PremioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          findFirst: {
            args: Prisma.PremioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PremioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          findMany: {
            args: Prisma.PremioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>[]
          }
          create: {
            args: Prisma.PremioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          createMany: {
            args: Prisma.PremioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PremioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>[]
          }
          delete: {
            args: Prisma.PremioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          update: {
            args: Prisma.PremioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          deleteMany: {
            args: Prisma.PremioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PremioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PremioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PremioPayload>
          }
          aggregate: {
            args: Prisma.PremioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePremio>
          }
          groupBy: {
            args: Prisma.PremioGroupByArgs<ExtArgs>
            result: $Utils.Optional<PremioGroupByOutputType>[]
          }
          count: {
            args: Prisma.PremioCountArgs<ExtArgs>
            result: $Utils.Optional<PremioCountAggregateOutputType> | number
          }
        }
      }
      Moto: {
        payload: Prisma.$MotoPayload<ExtArgs>
        fields: Prisma.MotoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MotoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MotoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotoPayload>
          }
          findFirst: {
            args: Prisma.MotoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MotoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotoPayload>
          }
          findMany: {
            args: Prisma.MotoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotoPayload>[]
          }
          create: {
            args: Prisma.MotoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotoPayload>
          }
          createMany: {
            args: Prisma.MotoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MotoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotoPayload>[]
          }
          delete: {
            args: Prisma.MotoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotoPayload>
          }
          update: {
            args: Prisma.MotoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotoPayload>
          }
          deleteMany: {
            args: Prisma.MotoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MotoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MotoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MotoPayload>
          }
          aggregate: {
            args: Prisma.MotoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMoto>
          }
          groupBy: {
            args: Prisma.MotoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MotoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MotoCountArgs<ExtArgs>
            result: $Utils.Optional<MotoCountAggregateOutputType> | number
          }
        }
      }
      Evento: {
        payload: Prisma.$EventoPayload<ExtArgs>
        fields: Prisma.EventoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          findFirst: {
            args: Prisma.EventoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          findMany: {
            args: Prisma.EventoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>[]
          }
          create: {
            args: Prisma.EventoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          createMany: {
            args: Prisma.EventoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>[]
          }
          delete: {
            args: Prisma.EventoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          update: {
            args: Prisma.EventoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          deleteMany: {
            args: Prisma.EventoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoPayload>
          }
          aggregate: {
            args: Prisma.EventoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvento>
          }
          groupBy: {
            args: Prisma.EventoGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventoGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventoCountArgs<ExtArgs>
            result: $Utils.Optional<EventoCountAggregateOutputType> | number
          }
        }
      }
      ParticipacaoEvento: {
        payload: Prisma.$ParticipacaoEventoPayload<ExtArgs>
        fields: Prisma.ParticipacaoEventoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParticipacaoEventoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacaoEventoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParticipacaoEventoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacaoEventoPayload>
          }
          findFirst: {
            args: Prisma.ParticipacaoEventoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacaoEventoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParticipacaoEventoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacaoEventoPayload>
          }
          findMany: {
            args: Prisma.ParticipacaoEventoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacaoEventoPayload>[]
          }
          create: {
            args: Prisma.ParticipacaoEventoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacaoEventoPayload>
          }
          createMany: {
            args: Prisma.ParticipacaoEventoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParticipacaoEventoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacaoEventoPayload>[]
          }
          delete: {
            args: Prisma.ParticipacaoEventoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacaoEventoPayload>
          }
          update: {
            args: Prisma.ParticipacaoEventoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacaoEventoPayload>
          }
          deleteMany: {
            args: Prisma.ParticipacaoEventoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParticipacaoEventoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ParticipacaoEventoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacaoEventoPayload>
          }
          aggregate: {
            args: Prisma.ParticipacaoEventoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParticipacaoEvento>
          }
          groupBy: {
            args: Prisma.ParticipacaoEventoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParticipacaoEventoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParticipacaoEventoCountArgs<ExtArgs>
            result: $Utils.Optional<ParticipacaoEventoCountAggregateOutputType> | number
          }
        }
      }
      ComboioEvento: {
        payload: Prisma.$ComboioEventoPayload<ExtArgs>
        fields: Prisma.ComboioEventoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComboioEventoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboioEventoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComboioEventoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboioEventoPayload>
          }
          findFirst: {
            args: Prisma.ComboioEventoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboioEventoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComboioEventoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboioEventoPayload>
          }
          findMany: {
            args: Prisma.ComboioEventoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboioEventoPayload>[]
          }
          create: {
            args: Prisma.ComboioEventoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboioEventoPayload>
          }
          createMany: {
            args: Prisma.ComboioEventoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComboioEventoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboioEventoPayload>[]
          }
          delete: {
            args: Prisma.ComboioEventoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboioEventoPayload>
          }
          update: {
            args: Prisma.ComboioEventoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboioEventoPayload>
          }
          deleteMany: {
            args: Prisma.ComboioEventoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComboioEventoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ComboioEventoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComboioEventoPayload>
          }
          aggregate: {
            args: Prisma.ComboioEventoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComboioEvento>
          }
          groupBy: {
            args: Prisma.ComboioEventoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComboioEventoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComboioEventoCountArgs<ExtArgs>
            result: $Utils.Optional<ComboioEventoCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    familiares: number
    premios: number
    motos: number
    participacoes: number
    comboiosLiderados: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familiares?: boolean | UserCountOutputTypeCountFamiliaresArgs
    premios?: boolean | UserCountOutputTypeCountPremiosArgs
    motos?: boolean | UserCountOutputTypeCountMotosArgs
    participacoes?: boolean | UserCountOutputTypeCountParticipacoesArgs
    comboiosLiderados?: boolean | UserCountOutputTypeCountComboiosLideradosArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFamiliaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamiliarWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPremiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PremioWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMotosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MotoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountParticipacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipacaoEventoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComboiosLideradosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComboioEventoWhereInput
  }


  /**
   * Count Type EventoCountOutputType
   */

  export type EventoCountOutputType = {
    participacoes: number
    comboios: number
  }

  export type EventoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacoes?: boolean | EventoCountOutputTypeCountParticipacoesArgs
    comboios?: boolean | EventoCountOutputTypeCountComboiosArgs
  }

  // Custom InputTypes
  /**
   * EventoCountOutputType without action
   */
  export type EventoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoCountOutputType
     */
    select?: EventoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventoCountOutputType without action
   */
  export type EventoCountOutputTypeCountParticipacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipacaoEventoWhereInput
  }

  /**
   * EventoCountOutputType without action
   */
  export type EventoCountOutputTypeCountComboiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComboioEventoWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    nomeCompleto: string | null
    telefone: string | null
    cidade: string | null
    estado: string | null
    dataNascimento: Date | null
    tipoUsuario: $Enums.UserType | null
    ativo: boolean | null
    emailVerificado: boolean | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    nomeCompleto: string | null
    telefone: string | null
    cidade: string | null
    estado: string | null
    dataNascimento: Date | null
    tipoUsuario: $Enums.UserType | null
    ativo: boolean | null
    emailVerificado: boolean | null
    avatarUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    nomeCompleto: number
    telefone: number
    cidade: number
    estado: number
    dataNascimento: number
    tipoUsuario: number
    ativo: number
    emailVerificado: number
    avatarUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nomeCompleto?: true
    telefone?: true
    cidade?: true
    estado?: true
    dataNascimento?: true
    tipoUsuario?: true
    ativo?: true
    emailVerificado?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nomeCompleto?: true
    telefone?: true
    cidade?: true
    estado?: true
    dataNascimento?: true
    tipoUsuario?: true
    ativo?: true
    emailVerificado?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    nomeCompleto?: true
    telefone?: true
    cidade?: true
    estado?: true
    dataNascimento?: true
    tipoUsuario?: true
    ativo?: true
    emailVerificado?: true
    avatarUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    nomeCompleto: string
    telefone: string | null
    cidade: string | null
    estado: string | null
    dataNascimento: Date | null
    tipoUsuario: $Enums.UserType
    ativo: boolean
    emailVerificado: boolean
    avatarUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nomeCompleto?: boolean
    telefone?: boolean
    cidade?: boolean
    estado?: boolean
    dataNascimento?: boolean
    tipoUsuario?: boolean
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    familiares?: boolean | User$familiaresArgs<ExtArgs>
    premios?: boolean | User$premiosArgs<ExtArgs>
    motos?: boolean | User$motosArgs<ExtArgs>
    participacoes?: boolean | User$participacoesArgs<ExtArgs>
    comboiosLiderados?: boolean | User$comboiosLideradosArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    nomeCompleto?: boolean
    telefone?: boolean
    cidade?: boolean
    estado?: boolean
    dataNascimento?: boolean
    tipoUsuario?: boolean
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    nomeCompleto?: boolean
    telefone?: boolean
    cidade?: boolean
    estado?: boolean
    dataNascimento?: boolean
    tipoUsuario?: boolean
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    familiares?: boolean | User$familiaresArgs<ExtArgs>
    premios?: boolean | User$premiosArgs<ExtArgs>
    motos?: boolean | User$motosArgs<ExtArgs>
    participacoes?: boolean | User$participacoesArgs<ExtArgs>
    comboiosLiderados?: boolean | User$comboiosLideradosArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      familiares: Prisma.$FamiliarPayload<ExtArgs>[]
      premios: Prisma.$PremioPayload<ExtArgs>[]
      motos: Prisma.$MotoPayload<ExtArgs>[]
      participacoes: Prisma.$ParticipacaoEventoPayload<ExtArgs>[]
      comboiosLiderados: Prisma.$ComboioEventoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      nomeCompleto: string
      telefone: string | null
      cidade: string | null
      estado: string | null
      dataNascimento: Date | null
      tipoUsuario: $Enums.UserType
      ativo: boolean
      emailVerificado: boolean
      avatarUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    familiares<T extends User$familiaresArgs<ExtArgs> = {}>(args?: Subset<T, User$familiaresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "findMany"> | Null>
    premios<T extends User$premiosArgs<ExtArgs> = {}>(args?: Subset<T, User$premiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "findMany"> | Null>
    motos<T extends User$motosArgs<ExtArgs> = {}>(args?: Subset<T, User$motosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "findMany"> | Null>
    participacoes<T extends User$participacoesArgs<ExtArgs> = {}>(args?: Subset<T, User$participacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "findMany"> | Null>
    comboiosLiderados<T extends User$comboiosLideradosArgs<ExtArgs> = {}>(args?: Subset<T, User$comboiosLideradosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly nomeCompleto: FieldRef<"User", 'String'>
    readonly telefone: FieldRef<"User", 'String'>
    readonly cidade: FieldRef<"User", 'String'>
    readonly estado: FieldRef<"User", 'String'>
    readonly dataNascimento: FieldRef<"User", 'DateTime'>
    readonly tipoUsuario: FieldRef<"User", 'UserType'>
    readonly ativo: FieldRef<"User", 'Boolean'>
    readonly emailVerificado: FieldRef<"User", 'Boolean'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.familiares
   */
  export type User$familiaresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
    where?: FamiliarWhereInput
    orderBy?: FamiliarOrderByWithRelationInput | FamiliarOrderByWithRelationInput[]
    cursor?: FamiliarWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FamiliarScalarFieldEnum | FamiliarScalarFieldEnum[]
  }

  /**
   * User.premios
   */
  export type User$premiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
    where?: PremioWhereInput
    orderBy?: PremioOrderByWithRelationInput | PremioOrderByWithRelationInput[]
    cursor?: PremioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PremioScalarFieldEnum | PremioScalarFieldEnum[]
  }

  /**
   * User.motos
   */
  export type User$motosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
    where?: MotoWhereInput
    orderBy?: MotoOrderByWithRelationInput | MotoOrderByWithRelationInput[]
    cursor?: MotoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MotoScalarFieldEnum | MotoScalarFieldEnum[]
  }

  /**
   * User.participacoes
   */
  export type User$participacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    where?: ParticipacaoEventoWhereInput
    orderBy?: ParticipacaoEventoOrderByWithRelationInput | ParticipacaoEventoOrderByWithRelationInput[]
    cursor?: ParticipacaoEventoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipacaoEventoScalarFieldEnum | ParticipacaoEventoScalarFieldEnum[]
  }

  /**
   * User.comboiosLiderados
   */
  export type User$comboiosLideradosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    where?: ComboioEventoWhereInput
    orderBy?: ComboioEventoOrderByWithRelationInput | ComboioEventoOrderByWithRelationInput[]
    cursor?: ComboioEventoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboioEventoScalarFieldEnum | ComboioEventoScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Familiar
   */

  export type AggregateFamiliar = {
    _count: FamiliarCountAggregateOutputType | null
    _avg: FamiliarAvgAggregateOutputType | null
    _sum: FamiliarSumAggregateOutputType | null
    _min: FamiliarMinAggregateOutputType | null
    _max: FamiliarMaxAggregateOutputType | null
  }

  export type FamiliarAvgAggregateOutputType = {
    idade: number | null
  }

  export type FamiliarSumAggregateOutputType = {
    idade: number | null
  }

  export type FamiliarMinAggregateOutputType = {
    id: string | null
    nome: string | null
    parentesco: string | null
    idade: number | null
    telefone: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamiliarMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    parentesco: string | null
    idade: number | null
    telefone: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FamiliarCountAggregateOutputType = {
    id: number
    nome: number
    parentesco: number
    idade: number
    telefone: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FamiliarAvgAggregateInputType = {
    idade?: true
  }

  export type FamiliarSumAggregateInputType = {
    idade?: true
  }

  export type FamiliarMinAggregateInputType = {
    id?: true
    nome?: true
    parentesco?: true
    idade?: true
    telefone?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamiliarMaxAggregateInputType = {
    id?: true
    nome?: true
    parentesco?: true
    idade?: true
    telefone?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FamiliarCountAggregateInputType = {
    id?: true
    nome?: true
    parentesco?: true
    idade?: true
    telefone?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FamiliarAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Familiar to aggregate.
     */
    where?: FamiliarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Familiars to fetch.
     */
    orderBy?: FamiliarOrderByWithRelationInput | FamiliarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FamiliarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Familiars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Familiars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Familiars
    **/
    _count?: true | FamiliarCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FamiliarAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FamiliarSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FamiliarMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FamiliarMaxAggregateInputType
  }

  export type GetFamiliarAggregateType<T extends FamiliarAggregateArgs> = {
        [P in keyof T & keyof AggregateFamiliar]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFamiliar[P]>
      : GetScalarType<T[P], AggregateFamiliar[P]>
  }




  export type FamiliarGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FamiliarWhereInput
    orderBy?: FamiliarOrderByWithAggregationInput | FamiliarOrderByWithAggregationInput[]
    by: FamiliarScalarFieldEnum[] | FamiliarScalarFieldEnum
    having?: FamiliarScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FamiliarCountAggregateInputType | true
    _avg?: FamiliarAvgAggregateInputType
    _sum?: FamiliarSumAggregateInputType
    _min?: FamiliarMinAggregateInputType
    _max?: FamiliarMaxAggregateInputType
  }

  export type FamiliarGroupByOutputType = {
    id: string
    nome: string
    parentesco: string
    idade: number | null
    telefone: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: FamiliarCountAggregateOutputType | null
    _avg: FamiliarAvgAggregateOutputType | null
    _sum: FamiliarSumAggregateOutputType | null
    _min: FamiliarMinAggregateOutputType | null
    _max: FamiliarMaxAggregateOutputType | null
  }

  type GetFamiliarGroupByPayload<T extends FamiliarGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FamiliarGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FamiliarGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FamiliarGroupByOutputType[P]>
            : GetScalarType<T[P], FamiliarGroupByOutputType[P]>
        }
      >
    >


  export type FamiliarSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    parentesco?: boolean
    idade?: boolean
    telefone?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familiar"]>

  export type FamiliarSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    parentesco?: boolean
    idade?: boolean
    telefone?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["familiar"]>

  export type FamiliarSelectScalar = {
    id?: boolean
    nome?: boolean
    parentesco?: boolean
    idade?: boolean
    telefone?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FamiliarInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FamiliarIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FamiliarPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Familiar"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      parentesco: string
      idade: number | null
      telefone: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["familiar"]>
    composites: {}
  }

  type FamiliarGetPayload<S extends boolean | null | undefined | FamiliarDefaultArgs> = $Result.GetResult<Prisma.$FamiliarPayload, S>

  type FamiliarCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FamiliarFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FamiliarCountAggregateInputType | true
    }

  export interface FamiliarDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Familiar'], meta: { name: 'Familiar' } }
    /**
     * Find zero or one Familiar that matches the filter.
     * @param {FamiliarFindUniqueArgs} args - Arguments to find a Familiar
     * @example
     * // Get one Familiar
     * const familiar = await prisma.familiar.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FamiliarFindUniqueArgs>(args: SelectSubset<T, FamiliarFindUniqueArgs<ExtArgs>>): Prisma__FamiliarClient<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Familiar that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FamiliarFindUniqueOrThrowArgs} args - Arguments to find a Familiar
     * @example
     * // Get one Familiar
     * const familiar = await prisma.familiar.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FamiliarFindUniqueOrThrowArgs>(args: SelectSubset<T, FamiliarFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FamiliarClient<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Familiar that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamiliarFindFirstArgs} args - Arguments to find a Familiar
     * @example
     * // Get one Familiar
     * const familiar = await prisma.familiar.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FamiliarFindFirstArgs>(args?: SelectSubset<T, FamiliarFindFirstArgs<ExtArgs>>): Prisma__FamiliarClient<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Familiar that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamiliarFindFirstOrThrowArgs} args - Arguments to find a Familiar
     * @example
     * // Get one Familiar
     * const familiar = await prisma.familiar.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FamiliarFindFirstOrThrowArgs>(args?: SelectSubset<T, FamiliarFindFirstOrThrowArgs<ExtArgs>>): Prisma__FamiliarClient<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Familiars that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamiliarFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Familiars
     * const familiars = await prisma.familiar.findMany()
     * 
     * // Get first 10 Familiars
     * const familiars = await prisma.familiar.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const familiarWithIdOnly = await prisma.familiar.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FamiliarFindManyArgs>(args?: SelectSubset<T, FamiliarFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Familiar.
     * @param {FamiliarCreateArgs} args - Arguments to create a Familiar.
     * @example
     * // Create one Familiar
     * const Familiar = await prisma.familiar.create({
     *   data: {
     *     // ... data to create a Familiar
     *   }
     * })
     * 
     */
    create<T extends FamiliarCreateArgs>(args: SelectSubset<T, FamiliarCreateArgs<ExtArgs>>): Prisma__FamiliarClient<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Familiars.
     * @param {FamiliarCreateManyArgs} args - Arguments to create many Familiars.
     * @example
     * // Create many Familiars
     * const familiar = await prisma.familiar.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FamiliarCreateManyArgs>(args?: SelectSubset<T, FamiliarCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Familiars and returns the data saved in the database.
     * @param {FamiliarCreateManyAndReturnArgs} args - Arguments to create many Familiars.
     * @example
     * // Create many Familiars
     * const familiar = await prisma.familiar.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Familiars and only return the `id`
     * const familiarWithIdOnly = await prisma.familiar.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FamiliarCreateManyAndReturnArgs>(args?: SelectSubset<T, FamiliarCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Familiar.
     * @param {FamiliarDeleteArgs} args - Arguments to delete one Familiar.
     * @example
     * // Delete one Familiar
     * const Familiar = await prisma.familiar.delete({
     *   where: {
     *     // ... filter to delete one Familiar
     *   }
     * })
     * 
     */
    delete<T extends FamiliarDeleteArgs>(args: SelectSubset<T, FamiliarDeleteArgs<ExtArgs>>): Prisma__FamiliarClient<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Familiar.
     * @param {FamiliarUpdateArgs} args - Arguments to update one Familiar.
     * @example
     * // Update one Familiar
     * const familiar = await prisma.familiar.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FamiliarUpdateArgs>(args: SelectSubset<T, FamiliarUpdateArgs<ExtArgs>>): Prisma__FamiliarClient<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Familiars.
     * @param {FamiliarDeleteManyArgs} args - Arguments to filter Familiars to delete.
     * @example
     * // Delete a few Familiars
     * const { count } = await prisma.familiar.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FamiliarDeleteManyArgs>(args?: SelectSubset<T, FamiliarDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Familiars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamiliarUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Familiars
     * const familiar = await prisma.familiar.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FamiliarUpdateManyArgs>(args: SelectSubset<T, FamiliarUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Familiar.
     * @param {FamiliarUpsertArgs} args - Arguments to update or create a Familiar.
     * @example
     * // Update or create a Familiar
     * const familiar = await prisma.familiar.upsert({
     *   create: {
     *     // ... data to create a Familiar
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Familiar we want to update
     *   }
     * })
     */
    upsert<T extends FamiliarUpsertArgs>(args: SelectSubset<T, FamiliarUpsertArgs<ExtArgs>>): Prisma__FamiliarClient<$Result.GetResult<Prisma.$FamiliarPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Familiars.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamiliarCountArgs} args - Arguments to filter Familiars to count.
     * @example
     * // Count the number of Familiars
     * const count = await prisma.familiar.count({
     *   where: {
     *     // ... the filter for the Familiars we want to count
     *   }
     * })
    **/
    count<T extends FamiliarCountArgs>(
      args?: Subset<T, FamiliarCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FamiliarCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Familiar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamiliarAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FamiliarAggregateArgs>(args: Subset<T, FamiliarAggregateArgs>): Prisma.PrismaPromise<GetFamiliarAggregateType<T>>

    /**
     * Group by Familiar.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FamiliarGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FamiliarGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FamiliarGroupByArgs['orderBy'] }
        : { orderBy?: FamiliarGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FamiliarGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFamiliarGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Familiar model
   */
  readonly fields: FamiliarFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Familiar.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FamiliarClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Familiar model
   */ 
  interface FamiliarFieldRefs {
    readonly id: FieldRef<"Familiar", 'String'>
    readonly nome: FieldRef<"Familiar", 'String'>
    readonly parentesco: FieldRef<"Familiar", 'String'>
    readonly idade: FieldRef<"Familiar", 'Int'>
    readonly telefone: FieldRef<"Familiar", 'String'>
    readonly userId: FieldRef<"Familiar", 'String'>
    readonly createdAt: FieldRef<"Familiar", 'DateTime'>
    readonly updatedAt: FieldRef<"Familiar", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Familiar findUnique
   */
  export type FamiliarFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
    /**
     * Filter, which Familiar to fetch.
     */
    where: FamiliarWhereUniqueInput
  }

  /**
   * Familiar findUniqueOrThrow
   */
  export type FamiliarFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
    /**
     * Filter, which Familiar to fetch.
     */
    where: FamiliarWhereUniqueInput
  }

  /**
   * Familiar findFirst
   */
  export type FamiliarFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
    /**
     * Filter, which Familiar to fetch.
     */
    where?: FamiliarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Familiars to fetch.
     */
    orderBy?: FamiliarOrderByWithRelationInput | FamiliarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Familiars.
     */
    cursor?: FamiliarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Familiars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Familiars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Familiars.
     */
    distinct?: FamiliarScalarFieldEnum | FamiliarScalarFieldEnum[]
  }

  /**
   * Familiar findFirstOrThrow
   */
  export type FamiliarFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
    /**
     * Filter, which Familiar to fetch.
     */
    where?: FamiliarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Familiars to fetch.
     */
    orderBy?: FamiliarOrderByWithRelationInput | FamiliarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Familiars.
     */
    cursor?: FamiliarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Familiars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Familiars.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Familiars.
     */
    distinct?: FamiliarScalarFieldEnum | FamiliarScalarFieldEnum[]
  }

  /**
   * Familiar findMany
   */
  export type FamiliarFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
    /**
     * Filter, which Familiars to fetch.
     */
    where?: FamiliarWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Familiars to fetch.
     */
    orderBy?: FamiliarOrderByWithRelationInput | FamiliarOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Familiars.
     */
    cursor?: FamiliarWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Familiars from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Familiars.
     */
    skip?: number
    distinct?: FamiliarScalarFieldEnum | FamiliarScalarFieldEnum[]
  }

  /**
   * Familiar create
   */
  export type FamiliarCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
    /**
     * The data needed to create a Familiar.
     */
    data: XOR<FamiliarCreateInput, FamiliarUncheckedCreateInput>
  }

  /**
   * Familiar createMany
   */
  export type FamiliarCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Familiars.
     */
    data: FamiliarCreateManyInput | FamiliarCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Familiar createManyAndReturn
   */
  export type FamiliarCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Familiars.
     */
    data: FamiliarCreateManyInput | FamiliarCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Familiar update
   */
  export type FamiliarUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
    /**
     * The data needed to update a Familiar.
     */
    data: XOR<FamiliarUpdateInput, FamiliarUncheckedUpdateInput>
    /**
     * Choose, which Familiar to update.
     */
    where: FamiliarWhereUniqueInput
  }

  /**
   * Familiar updateMany
   */
  export type FamiliarUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Familiars.
     */
    data: XOR<FamiliarUpdateManyMutationInput, FamiliarUncheckedUpdateManyInput>
    /**
     * Filter which Familiars to update
     */
    where?: FamiliarWhereInput
  }

  /**
   * Familiar upsert
   */
  export type FamiliarUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
    /**
     * The filter to search for the Familiar to update in case it exists.
     */
    where: FamiliarWhereUniqueInput
    /**
     * In case the Familiar found by the `where` argument doesn't exist, create a new Familiar with this data.
     */
    create: XOR<FamiliarCreateInput, FamiliarUncheckedCreateInput>
    /**
     * In case the Familiar was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FamiliarUpdateInput, FamiliarUncheckedUpdateInput>
  }

  /**
   * Familiar delete
   */
  export type FamiliarDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
    /**
     * Filter which Familiar to delete.
     */
    where: FamiliarWhereUniqueInput
  }

  /**
   * Familiar deleteMany
   */
  export type FamiliarDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Familiars to delete
     */
    where?: FamiliarWhereInput
  }

  /**
   * Familiar without action
   */
  export type FamiliarDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Familiar
     */
    select?: FamiliarSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FamiliarInclude<ExtArgs> | null
  }


  /**
   * Model Premio
   */

  export type AggregatePremio = {
    _count: PremioCountAggregateOutputType | null
    _avg: PremioAvgAggregateOutputType | null
    _sum: PremioSumAggregateOutputType | null
    _min: PremioMinAggregateOutputType | null
    _max: PremioMaxAggregateOutputType | null
  }

  export type PremioAvgAggregateOutputType = {
    ano: number | null
  }

  export type PremioSumAggregateOutputType = {
    ano: number | null
  }

  export type PremioMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    descricao: string | null
    categoria: string | null
    ano: number | null
    posicao: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PremioMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    descricao: string | null
    categoria: string | null
    ano: number | null
    posicao: string | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PremioCountAggregateOutputType = {
    id: number
    titulo: number
    descricao: number
    categoria: number
    ano: number
    posicao: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PremioAvgAggregateInputType = {
    ano?: true
  }

  export type PremioSumAggregateInputType = {
    ano?: true
  }

  export type PremioMinAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    categoria?: true
    ano?: true
    posicao?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PremioMaxAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    categoria?: true
    ano?: true
    posicao?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PremioCountAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    categoria?: true
    ano?: true
    posicao?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PremioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Premio to aggregate.
     */
    where?: PremioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Premios to fetch.
     */
    orderBy?: PremioOrderByWithRelationInput | PremioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PremioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Premios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Premios
    **/
    _count?: true | PremioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PremioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PremioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PremioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PremioMaxAggregateInputType
  }

  export type GetPremioAggregateType<T extends PremioAggregateArgs> = {
        [P in keyof T & keyof AggregatePremio]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePremio[P]>
      : GetScalarType<T[P], AggregatePremio[P]>
  }




  export type PremioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PremioWhereInput
    orderBy?: PremioOrderByWithAggregationInput | PremioOrderByWithAggregationInput[]
    by: PremioScalarFieldEnum[] | PremioScalarFieldEnum
    having?: PremioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PremioCountAggregateInputType | true
    _avg?: PremioAvgAggregateInputType
    _sum?: PremioSumAggregateInputType
    _min?: PremioMinAggregateInputType
    _max?: PremioMaxAggregateInputType
  }

  export type PremioGroupByOutputType = {
    id: string
    titulo: string
    descricao: string | null
    categoria: string
    ano: number
    posicao: string | null
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: PremioCountAggregateOutputType | null
    _avg: PremioAvgAggregateOutputType | null
    _sum: PremioSumAggregateOutputType | null
    _min: PremioMinAggregateOutputType | null
    _max: PremioMaxAggregateOutputType | null
  }

  type GetPremioGroupByPayload<T extends PremioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PremioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PremioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PremioGroupByOutputType[P]>
            : GetScalarType<T[P], PremioGroupByOutputType[P]>
        }
      >
    >


  export type PremioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    categoria?: boolean
    ano?: boolean
    posicao?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["premio"]>

  export type PremioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    categoria?: boolean
    ano?: boolean
    posicao?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["premio"]>

  export type PremioSelectScalar = {
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    categoria?: boolean
    ano?: boolean
    posicao?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PremioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PremioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PremioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Premio"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      descricao: string | null
      categoria: string
      ano: number
      posicao: string | null
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["premio"]>
    composites: {}
  }

  type PremioGetPayload<S extends boolean | null | undefined | PremioDefaultArgs> = $Result.GetResult<Prisma.$PremioPayload, S>

  type PremioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PremioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PremioCountAggregateInputType | true
    }

  export interface PremioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Premio'], meta: { name: 'Premio' } }
    /**
     * Find zero or one Premio that matches the filter.
     * @param {PremioFindUniqueArgs} args - Arguments to find a Premio
     * @example
     * // Get one Premio
     * const premio = await prisma.premio.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PremioFindUniqueArgs>(args: SelectSubset<T, PremioFindUniqueArgs<ExtArgs>>): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Premio that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PremioFindUniqueOrThrowArgs} args - Arguments to find a Premio
     * @example
     * // Get one Premio
     * const premio = await prisma.premio.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PremioFindUniqueOrThrowArgs>(args: SelectSubset<T, PremioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Premio that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioFindFirstArgs} args - Arguments to find a Premio
     * @example
     * // Get one Premio
     * const premio = await prisma.premio.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PremioFindFirstArgs>(args?: SelectSubset<T, PremioFindFirstArgs<ExtArgs>>): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Premio that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioFindFirstOrThrowArgs} args - Arguments to find a Premio
     * @example
     * // Get one Premio
     * const premio = await prisma.premio.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PremioFindFirstOrThrowArgs>(args?: SelectSubset<T, PremioFindFirstOrThrowArgs<ExtArgs>>): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Premios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Premios
     * const premios = await prisma.premio.findMany()
     * 
     * // Get first 10 Premios
     * const premios = await prisma.premio.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const premioWithIdOnly = await prisma.premio.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PremioFindManyArgs>(args?: SelectSubset<T, PremioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Premio.
     * @param {PremioCreateArgs} args - Arguments to create a Premio.
     * @example
     * // Create one Premio
     * const Premio = await prisma.premio.create({
     *   data: {
     *     // ... data to create a Premio
     *   }
     * })
     * 
     */
    create<T extends PremioCreateArgs>(args: SelectSubset<T, PremioCreateArgs<ExtArgs>>): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Premios.
     * @param {PremioCreateManyArgs} args - Arguments to create many Premios.
     * @example
     * // Create many Premios
     * const premio = await prisma.premio.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PremioCreateManyArgs>(args?: SelectSubset<T, PremioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Premios and returns the data saved in the database.
     * @param {PremioCreateManyAndReturnArgs} args - Arguments to create many Premios.
     * @example
     * // Create many Premios
     * const premio = await prisma.premio.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Premios and only return the `id`
     * const premioWithIdOnly = await prisma.premio.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PremioCreateManyAndReturnArgs>(args?: SelectSubset<T, PremioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Premio.
     * @param {PremioDeleteArgs} args - Arguments to delete one Premio.
     * @example
     * // Delete one Premio
     * const Premio = await prisma.premio.delete({
     *   where: {
     *     // ... filter to delete one Premio
     *   }
     * })
     * 
     */
    delete<T extends PremioDeleteArgs>(args: SelectSubset<T, PremioDeleteArgs<ExtArgs>>): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Premio.
     * @param {PremioUpdateArgs} args - Arguments to update one Premio.
     * @example
     * // Update one Premio
     * const premio = await prisma.premio.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PremioUpdateArgs>(args: SelectSubset<T, PremioUpdateArgs<ExtArgs>>): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Premios.
     * @param {PremioDeleteManyArgs} args - Arguments to filter Premios to delete.
     * @example
     * // Delete a few Premios
     * const { count } = await prisma.premio.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PremioDeleteManyArgs>(args?: SelectSubset<T, PremioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Premios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Premios
     * const premio = await prisma.premio.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PremioUpdateManyArgs>(args: SelectSubset<T, PremioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Premio.
     * @param {PremioUpsertArgs} args - Arguments to update or create a Premio.
     * @example
     * // Update or create a Premio
     * const premio = await prisma.premio.upsert({
     *   create: {
     *     // ... data to create a Premio
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Premio we want to update
     *   }
     * })
     */
    upsert<T extends PremioUpsertArgs>(args: SelectSubset<T, PremioUpsertArgs<ExtArgs>>): Prisma__PremioClient<$Result.GetResult<Prisma.$PremioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Premios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioCountArgs} args - Arguments to filter Premios to count.
     * @example
     * // Count the number of Premios
     * const count = await prisma.premio.count({
     *   where: {
     *     // ... the filter for the Premios we want to count
     *   }
     * })
    **/
    count<T extends PremioCountArgs>(
      args?: Subset<T, PremioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PremioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Premio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PremioAggregateArgs>(args: Subset<T, PremioAggregateArgs>): Prisma.PrismaPromise<GetPremioAggregateType<T>>

    /**
     * Group by Premio.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PremioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PremioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PremioGroupByArgs['orderBy'] }
        : { orderBy?: PremioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PremioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPremioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Premio model
   */
  readonly fields: PremioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Premio.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PremioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Premio model
   */ 
  interface PremioFieldRefs {
    readonly id: FieldRef<"Premio", 'String'>
    readonly titulo: FieldRef<"Premio", 'String'>
    readonly descricao: FieldRef<"Premio", 'String'>
    readonly categoria: FieldRef<"Premio", 'String'>
    readonly ano: FieldRef<"Premio", 'Int'>
    readonly posicao: FieldRef<"Premio", 'String'>
    readonly userId: FieldRef<"Premio", 'String'>
    readonly createdAt: FieldRef<"Premio", 'DateTime'>
    readonly updatedAt: FieldRef<"Premio", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Premio findUnique
   */
  export type PremioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
    /**
     * Filter, which Premio to fetch.
     */
    where: PremioWhereUniqueInput
  }

  /**
   * Premio findUniqueOrThrow
   */
  export type PremioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
    /**
     * Filter, which Premio to fetch.
     */
    where: PremioWhereUniqueInput
  }

  /**
   * Premio findFirst
   */
  export type PremioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
    /**
     * Filter, which Premio to fetch.
     */
    where?: PremioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Premios to fetch.
     */
    orderBy?: PremioOrderByWithRelationInput | PremioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Premios.
     */
    cursor?: PremioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Premios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Premios.
     */
    distinct?: PremioScalarFieldEnum | PremioScalarFieldEnum[]
  }

  /**
   * Premio findFirstOrThrow
   */
  export type PremioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
    /**
     * Filter, which Premio to fetch.
     */
    where?: PremioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Premios to fetch.
     */
    orderBy?: PremioOrderByWithRelationInput | PremioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Premios.
     */
    cursor?: PremioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Premios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Premios.
     */
    distinct?: PremioScalarFieldEnum | PremioScalarFieldEnum[]
  }

  /**
   * Premio findMany
   */
  export type PremioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
    /**
     * Filter, which Premios to fetch.
     */
    where?: PremioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Premios to fetch.
     */
    orderBy?: PremioOrderByWithRelationInput | PremioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Premios.
     */
    cursor?: PremioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Premios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Premios.
     */
    skip?: number
    distinct?: PremioScalarFieldEnum | PremioScalarFieldEnum[]
  }

  /**
   * Premio create
   */
  export type PremioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
    /**
     * The data needed to create a Premio.
     */
    data: XOR<PremioCreateInput, PremioUncheckedCreateInput>
  }

  /**
   * Premio createMany
   */
  export type PremioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Premios.
     */
    data: PremioCreateManyInput | PremioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Premio createManyAndReturn
   */
  export type PremioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Premios.
     */
    data: PremioCreateManyInput | PremioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Premio update
   */
  export type PremioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
    /**
     * The data needed to update a Premio.
     */
    data: XOR<PremioUpdateInput, PremioUncheckedUpdateInput>
    /**
     * Choose, which Premio to update.
     */
    where: PremioWhereUniqueInput
  }

  /**
   * Premio updateMany
   */
  export type PremioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Premios.
     */
    data: XOR<PremioUpdateManyMutationInput, PremioUncheckedUpdateManyInput>
    /**
     * Filter which Premios to update
     */
    where?: PremioWhereInput
  }

  /**
   * Premio upsert
   */
  export type PremioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
    /**
     * The filter to search for the Premio to update in case it exists.
     */
    where: PremioWhereUniqueInput
    /**
     * In case the Premio found by the `where` argument doesn't exist, create a new Premio with this data.
     */
    create: XOR<PremioCreateInput, PremioUncheckedCreateInput>
    /**
     * In case the Premio was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PremioUpdateInput, PremioUncheckedUpdateInput>
  }

  /**
   * Premio delete
   */
  export type PremioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
    /**
     * Filter which Premio to delete.
     */
    where: PremioWhereUniqueInput
  }

  /**
   * Premio deleteMany
   */
  export type PremioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Premios to delete
     */
    where?: PremioWhereInput
  }

  /**
   * Premio without action
   */
  export type PremioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Premio
     */
    select?: PremioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PremioInclude<ExtArgs> | null
  }


  /**
   * Model Moto
   */

  export type AggregateMoto = {
    _count: MotoCountAggregateOutputType | null
    _avg: MotoAvgAggregateOutputType | null
    _sum: MotoSumAggregateOutputType | null
    _min: MotoMinAggregateOutputType | null
    _max: MotoMaxAggregateOutputType | null
  }

  export type MotoAvgAggregateOutputType = {
    ano: number | null
  }

  export type MotoSumAggregateOutputType = {
    ano: number | null
  }

  export type MotoMinAggregateOutputType = {
    id: string | null
    marca: string | null
    modelo: string | null
    ano: number | null
    cor: string | null
    cilindrada: string | null
    placa: string | null
    principal: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MotoMaxAggregateOutputType = {
    id: string | null
    marca: string | null
    modelo: string | null
    ano: number | null
    cor: string | null
    cilindrada: string | null
    placa: string | null
    principal: boolean | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MotoCountAggregateOutputType = {
    id: number
    marca: number
    modelo: number
    ano: number
    cor: number
    cilindrada: number
    placa: number
    principal: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MotoAvgAggregateInputType = {
    ano?: true
  }

  export type MotoSumAggregateInputType = {
    ano?: true
  }

  export type MotoMinAggregateInputType = {
    id?: true
    marca?: true
    modelo?: true
    ano?: true
    cor?: true
    cilindrada?: true
    placa?: true
    principal?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MotoMaxAggregateInputType = {
    id?: true
    marca?: true
    modelo?: true
    ano?: true
    cor?: true
    cilindrada?: true
    placa?: true
    principal?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MotoCountAggregateInputType = {
    id?: true
    marca?: true
    modelo?: true
    ano?: true
    cor?: true
    cilindrada?: true
    placa?: true
    principal?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MotoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Moto to aggregate.
     */
    where?: MotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motos to fetch.
     */
    orderBy?: MotoOrderByWithRelationInput | MotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Motos
    **/
    _count?: true | MotoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MotoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MotoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MotoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MotoMaxAggregateInputType
  }

  export type GetMotoAggregateType<T extends MotoAggregateArgs> = {
        [P in keyof T & keyof AggregateMoto]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMoto[P]>
      : GetScalarType<T[P], AggregateMoto[P]>
  }




  export type MotoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MotoWhereInput
    orderBy?: MotoOrderByWithAggregationInput | MotoOrderByWithAggregationInput[]
    by: MotoScalarFieldEnum[] | MotoScalarFieldEnum
    having?: MotoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MotoCountAggregateInputType | true
    _avg?: MotoAvgAggregateInputType
    _sum?: MotoSumAggregateInputType
    _min?: MotoMinAggregateInputType
    _max?: MotoMaxAggregateInputType
  }

  export type MotoGroupByOutputType = {
    id: string
    marca: string
    modelo: string
    ano: number
    cor: string
    cilindrada: string
    placa: string | null
    principal: boolean
    userId: string
    createdAt: Date
    updatedAt: Date
    _count: MotoCountAggregateOutputType | null
    _avg: MotoAvgAggregateOutputType | null
    _sum: MotoSumAggregateOutputType | null
    _min: MotoMinAggregateOutputType | null
    _max: MotoMaxAggregateOutputType | null
  }

  type GetMotoGroupByPayload<T extends MotoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MotoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MotoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MotoGroupByOutputType[P]>
            : GetScalarType<T[P], MotoGroupByOutputType[P]>
        }
      >
    >


  export type MotoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marca?: boolean
    modelo?: boolean
    ano?: boolean
    cor?: boolean
    cilindrada?: boolean
    placa?: boolean
    principal?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moto"]>

  export type MotoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    marca?: boolean
    modelo?: boolean
    ano?: boolean
    cor?: boolean
    cilindrada?: boolean
    placa?: boolean
    principal?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["moto"]>

  export type MotoSelectScalar = {
    id?: boolean
    marca?: boolean
    modelo?: boolean
    ano?: boolean
    cor?: boolean
    cilindrada?: boolean
    placa?: boolean
    principal?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MotoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MotoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MotoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Moto"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      marca: string
      modelo: string
      ano: number
      cor: string
      cilindrada: string
      placa: string | null
      principal: boolean
      userId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["moto"]>
    composites: {}
  }

  type MotoGetPayload<S extends boolean | null | undefined | MotoDefaultArgs> = $Result.GetResult<Prisma.$MotoPayload, S>

  type MotoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MotoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MotoCountAggregateInputType | true
    }

  export interface MotoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Moto'], meta: { name: 'Moto' } }
    /**
     * Find zero or one Moto that matches the filter.
     * @param {MotoFindUniqueArgs} args - Arguments to find a Moto
     * @example
     * // Get one Moto
     * const moto = await prisma.moto.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MotoFindUniqueArgs>(args: SelectSubset<T, MotoFindUniqueArgs<ExtArgs>>): Prisma__MotoClient<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Moto that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MotoFindUniqueOrThrowArgs} args - Arguments to find a Moto
     * @example
     * // Get one Moto
     * const moto = await prisma.moto.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MotoFindUniqueOrThrowArgs>(args: SelectSubset<T, MotoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MotoClient<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Moto that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotoFindFirstArgs} args - Arguments to find a Moto
     * @example
     * // Get one Moto
     * const moto = await prisma.moto.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MotoFindFirstArgs>(args?: SelectSubset<T, MotoFindFirstArgs<ExtArgs>>): Prisma__MotoClient<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Moto that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotoFindFirstOrThrowArgs} args - Arguments to find a Moto
     * @example
     * // Get one Moto
     * const moto = await prisma.moto.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MotoFindFirstOrThrowArgs>(args?: SelectSubset<T, MotoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MotoClient<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Motos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Motos
     * const motos = await prisma.moto.findMany()
     * 
     * // Get first 10 Motos
     * const motos = await prisma.moto.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const motoWithIdOnly = await prisma.moto.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MotoFindManyArgs>(args?: SelectSubset<T, MotoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Moto.
     * @param {MotoCreateArgs} args - Arguments to create a Moto.
     * @example
     * // Create one Moto
     * const Moto = await prisma.moto.create({
     *   data: {
     *     // ... data to create a Moto
     *   }
     * })
     * 
     */
    create<T extends MotoCreateArgs>(args: SelectSubset<T, MotoCreateArgs<ExtArgs>>): Prisma__MotoClient<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Motos.
     * @param {MotoCreateManyArgs} args - Arguments to create many Motos.
     * @example
     * // Create many Motos
     * const moto = await prisma.moto.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MotoCreateManyArgs>(args?: SelectSubset<T, MotoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Motos and returns the data saved in the database.
     * @param {MotoCreateManyAndReturnArgs} args - Arguments to create many Motos.
     * @example
     * // Create many Motos
     * const moto = await prisma.moto.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Motos and only return the `id`
     * const motoWithIdOnly = await prisma.moto.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MotoCreateManyAndReturnArgs>(args?: SelectSubset<T, MotoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Moto.
     * @param {MotoDeleteArgs} args - Arguments to delete one Moto.
     * @example
     * // Delete one Moto
     * const Moto = await prisma.moto.delete({
     *   where: {
     *     // ... filter to delete one Moto
     *   }
     * })
     * 
     */
    delete<T extends MotoDeleteArgs>(args: SelectSubset<T, MotoDeleteArgs<ExtArgs>>): Prisma__MotoClient<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Moto.
     * @param {MotoUpdateArgs} args - Arguments to update one Moto.
     * @example
     * // Update one Moto
     * const moto = await prisma.moto.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MotoUpdateArgs>(args: SelectSubset<T, MotoUpdateArgs<ExtArgs>>): Prisma__MotoClient<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Motos.
     * @param {MotoDeleteManyArgs} args - Arguments to filter Motos to delete.
     * @example
     * // Delete a few Motos
     * const { count } = await prisma.moto.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MotoDeleteManyArgs>(args?: SelectSubset<T, MotoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Motos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Motos
     * const moto = await prisma.moto.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MotoUpdateManyArgs>(args: SelectSubset<T, MotoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Moto.
     * @param {MotoUpsertArgs} args - Arguments to update or create a Moto.
     * @example
     * // Update or create a Moto
     * const moto = await prisma.moto.upsert({
     *   create: {
     *     // ... data to create a Moto
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Moto we want to update
     *   }
     * })
     */
    upsert<T extends MotoUpsertArgs>(args: SelectSubset<T, MotoUpsertArgs<ExtArgs>>): Prisma__MotoClient<$Result.GetResult<Prisma.$MotoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Motos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotoCountArgs} args - Arguments to filter Motos to count.
     * @example
     * // Count the number of Motos
     * const count = await prisma.moto.count({
     *   where: {
     *     // ... the filter for the Motos we want to count
     *   }
     * })
    **/
    count<T extends MotoCountArgs>(
      args?: Subset<T, MotoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MotoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Moto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MotoAggregateArgs>(args: Subset<T, MotoAggregateArgs>): Prisma.PrismaPromise<GetMotoAggregateType<T>>

    /**
     * Group by Moto.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MotoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MotoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MotoGroupByArgs['orderBy'] }
        : { orderBy?: MotoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MotoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMotoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Moto model
   */
  readonly fields: MotoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Moto.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MotoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Moto model
   */ 
  interface MotoFieldRefs {
    readonly id: FieldRef<"Moto", 'String'>
    readonly marca: FieldRef<"Moto", 'String'>
    readonly modelo: FieldRef<"Moto", 'String'>
    readonly ano: FieldRef<"Moto", 'Int'>
    readonly cor: FieldRef<"Moto", 'String'>
    readonly cilindrada: FieldRef<"Moto", 'String'>
    readonly placa: FieldRef<"Moto", 'String'>
    readonly principal: FieldRef<"Moto", 'Boolean'>
    readonly userId: FieldRef<"Moto", 'String'>
    readonly createdAt: FieldRef<"Moto", 'DateTime'>
    readonly updatedAt: FieldRef<"Moto", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Moto findUnique
   */
  export type MotoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
    /**
     * Filter, which Moto to fetch.
     */
    where: MotoWhereUniqueInput
  }

  /**
   * Moto findUniqueOrThrow
   */
  export type MotoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
    /**
     * Filter, which Moto to fetch.
     */
    where: MotoWhereUniqueInput
  }

  /**
   * Moto findFirst
   */
  export type MotoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
    /**
     * Filter, which Moto to fetch.
     */
    where?: MotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motos to fetch.
     */
    orderBy?: MotoOrderByWithRelationInput | MotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motos.
     */
    cursor?: MotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motos.
     */
    distinct?: MotoScalarFieldEnum | MotoScalarFieldEnum[]
  }

  /**
   * Moto findFirstOrThrow
   */
  export type MotoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
    /**
     * Filter, which Moto to fetch.
     */
    where?: MotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motos to fetch.
     */
    orderBy?: MotoOrderByWithRelationInput | MotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Motos.
     */
    cursor?: MotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Motos.
     */
    distinct?: MotoScalarFieldEnum | MotoScalarFieldEnum[]
  }

  /**
   * Moto findMany
   */
  export type MotoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
    /**
     * Filter, which Motos to fetch.
     */
    where?: MotoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Motos to fetch.
     */
    orderBy?: MotoOrderByWithRelationInput | MotoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Motos.
     */
    cursor?: MotoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Motos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Motos.
     */
    skip?: number
    distinct?: MotoScalarFieldEnum | MotoScalarFieldEnum[]
  }

  /**
   * Moto create
   */
  export type MotoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
    /**
     * The data needed to create a Moto.
     */
    data: XOR<MotoCreateInput, MotoUncheckedCreateInput>
  }

  /**
   * Moto createMany
   */
  export type MotoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Motos.
     */
    data: MotoCreateManyInput | MotoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Moto createManyAndReturn
   */
  export type MotoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Motos.
     */
    data: MotoCreateManyInput | MotoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Moto update
   */
  export type MotoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
    /**
     * The data needed to update a Moto.
     */
    data: XOR<MotoUpdateInput, MotoUncheckedUpdateInput>
    /**
     * Choose, which Moto to update.
     */
    where: MotoWhereUniqueInput
  }

  /**
   * Moto updateMany
   */
  export type MotoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Motos.
     */
    data: XOR<MotoUpdateManyMutationInput, MotoUncheckedUpdateManyInput>
    /**
     * Filter which Motos to update
     */
    where?: MotoWhereInput
  }

  /**
   * Moto upsert
   */
  export type MotoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
    /**
     * The filter to search for the Moto to update in case it exists.
     */
    where: MotoWhereUniqueInput
    /**
     * In case the Moto found by the `where` argument doesn't exist, create a new Moto with this data.
     */
    create: XOR<MotoCreateInput, MotoUncheckedCreateInput>
    /**
     * In case the Moto was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MotoUpdateInput, MotoUncheckedUpdateInput>
  }

  /**
   * Moto delete
   */
  export type MotoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
    /**
     * Filter which Moto to delete.
     */
    where: MotoWhereUniqueInput
  }

  /**
   * Moto deleteMany
   */
  export type MotoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Motos to delete
     */
    where?: MotoWhereInput
  }

  /**
   * Moto without action
   */
  export type MotoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Moto
     */
    select?: MotoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MotoInclude<ExtArgs> | null
  }


  /**
   * Model Evento
   */

  export type AggregateEvento = {
    _count: EventoCountAggregateOutputType | null
    _avg: EventoAvgAggregateOutputType | null
    _sum: EventoSumAggregateOutputType | null
    _min: EventoMinAggregateOutputType | null
    _max: EventoMaxAggregateOutputType | null
  }

  export type EventoAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    participantesMaximo: number | null
    valorInscricao: number | null
  }

  export type EventoSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    participantesMaximo: number | null
    valorInscricao: number | null
  }

  export type EventoMinAggregateOutputType = {
    id: string | null
    titulo: string | null
    descricao: string | null
    dataEvento: Date | null
    localEvento: string | null
    endereco: string | null
    latitude: number | null
    longitude: number | null
    participantesMaximo: number | null
    valorInscricao: number | null
    ativo: boolean | null
    imagemUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventoMaxAggregateOutputType = {
    id: string | null
    titulo: string | null
    descricao: string | null
    dataEvento: Date | null
    localEvento: string | null
    endereco: string | null
    latitude: number | null
    longitude: number | null
    participantesMaximo: number | null
    valorInscricao: number | null
    ativo: boolean | null
    imagemUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventoCountAggregateOutputType = {
    id: number
    titulo: number
    descricao: number
    dataEvento: number
    localEvento: number
    endereco: number
    latitude: number
    longitude: number
    participantesMaximo: number
    valorInscricao: number
    ativo: number
    imagemUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventoAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    participantesMaximo?: true
    valorInscricao?: true
  }

  export type EventoSumAggregateInputType = {
    latitude?: true
    longitude?: true
    participantesMaximo?: true
    valorInscricao?: true
  }

  export type EventoMinAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    dataEvento?: true
    localEvento?: true
    endereco?: true
    latitude?: true
    longitude?: true
    participantesMaximo?: true
    valorInscricao?: true
    ativo?: true
    imagemUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventoMaxAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    dataEvento?: true
    localEvento?: true
    endereco?: true
    latitude?: true
    longitude?: true
    participantesMaximo?: true
    valorInscricao?: true
    ativo?: true
    imagemUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventoCountAggregateInputType = {
    id?: true
    titulo?: true
    descricao?: true
    dataEvento?: true
    localEvento?: true
    endereco?: true
    latitude?: true
    longitude?: true
    participantesMaximo?: true
    valorInscricao?: true
    ativo?: true
    imagemUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evento to aggregate.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Eventos
    **/
    _count?: true | EventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventoMaxAggregateInputType
  }

  export type GetEventoAggregateType<T extends EventoAggregateArgs> = {
        [P in keyof T & keyof AggregateEvento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvento[P]>
      : GetScalarType<T[P], AggregateEvento[P]>
  }




  export type EventoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoWhereInput
    orderBy?: EventoOrderByWithAggregationInput | EventoOrderByWithAggregationInput[]
    by: EventoScalarFieldEnum[] | EventoScalarFieldEnum
    having?: EventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventoCountAggregateInputType | true
    _avg?: EventoAvgAggregateInputType
    _sum?: EventoSumAggregateInputType
    _min?: EventoMinAggregateInputType
    _max?: EventoMaxAggregateInputType
  }

  export type EventoGroupByOutputType = {
    id: string
    titulo: string
    descricao: string
    dataEvento: Date
    localEvento: string
    endereco: string
    latitude: number | null
    longitude: number | null
    participantesMaximo: number | null
    valorInscricao: number | null
    ativo: boolean
    imagemUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: EventoCountAggregateOutputType | null
    _avg: EventoAvgAggregateOutputType | null
    _sum: EventoSumAggregateOutputType | null
    _min: EventoMinAggregateOutputType | null
    _max: EventoMaxAggregateOutputType | null
  }

  type GetEventoGroupByPayload<T extends EventoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventoGroupByOutputType[P]>
            : GetScalarType<T[P], EventoGroupByOutputType[P]>
        }
      >
    >


  export type EventoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    dataEvento?: boolean
    localEvento?: boolean
    endereco?: boolean
    latitude?: boolean
    longitude?: boolean
    participantesMaximo?: boolean
    valorInscricao?: boolean
    ativo?: boolean
    imagemUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    participacoes?: boolean | Evento$participacoesArgs<ExtArgs>
    comboios?: boolean | Evento$comboiosArgs<ExtArgs>
    _count?: boolean | EventoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["evento"]>

  export type EventoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    dataEvento?: boolean
    localEvento?: boolean
    endereco?: boolean
    latitude?: boolean
    longitude?: boolean
    participantesMaximo?: boolean
    valorInscricao?: boolean
    ativo?: boolean
    imagemUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["evento"]>

  export type EventoSelectScalar = {
    id?: boolean
    titulo?: boolean
    descricao?: boolean
    dataEvento?: boolean
    localEvento?: boolean
    endereco?: boolean
    latitude?: boolean
    longitude?: boolean
    participantesMaximo?: boolean
    valorInscricao?: boolean
    ativo?: boolean
    imagemUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacoes?: boolean | Evento$participacoesArgs<ExtArgs>
    comboios?: boolean | Evento$comboiosArgs<ExtArgs>
    _count?: boolean | EventoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EventoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evento"
    objects: {
      participacoes: Prisma.$ParticipacaoEventoPayload<ExtArgs>[]
      comboios: Prisma.$ComboioEventoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titulo: string
      descricao: string
      dataEvento: Date
      localEvento: string
      endereco: string
      latitude: number | null
      longitude: number | null
      participantesMaximo: number | null
      valorInscricao: number | null
      ativo: boolean
      imagemUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["evento"]>
    composites: {}
  }

  type EventoGetPayload<S extends boolean | null | undefined | EventoDefaultArgs> = $Result.GetResult<Prisma.$EventoPayload, S>

  type EventoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventoCountAggregateInputType | true
    }

  export interface EventoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evento'], meta: { name: 'Evento' } }
    /**
     * Find zero or one Evento that matches the filter.
     * @param {EventoFindUniqueArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventoFindUniqueArgs>(args: SelectSubset<T, EventoFindUniqueArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Evento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventoFindUniqueOrThrowArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventoFindUniqueOrThrowArgs>(args: SelectSubset<T, EventoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Evento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindFirstArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventoFindFirstArgs>(args?: SelectSubset<T, EventoFindFirstArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Evento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindFirstOrThrowArgs} args - Arguments to find a Evento
     * @example
     * // Get one Evento
     * const evento = await prisma.evento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventoFindFirstOrThrowArgs>(args?: SelectSubset<T, EventoFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Eventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Eventos
     * const eventos = await prisma.evento.findMany()
     * 
     * // Get first 10 Eventos
     * const eventos = await prisma.evento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventoWithIdOnly = await prisma.evento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventoFindManyArgs>(args?: SelectSubset<T, EventoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Evento.
     * @param {EventoCreateArgs} args - Arguments to create a Evento.
     * @example
     * // Create one Evento
     * const Evento = await prisma.evento.create({
     *   data: {
     *     // ... data to create a Evento
     *   }
     * })
     * 
     */
    create<T extends EventoCreateArgs>(args: SelectSubset<T, EventoCreateArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Eventos.
     * @param {EventoCreateManyArgs} args - Arguments to create many Eventos.
     * @example
     * // Create many Eventos
     * const evento = await prisma.evento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventoCreateManyArgs>(args?: SelectSubset<T, EventoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Eventos and returns the data saved in the database.
     * @param {EventoCreateManyAndReturnArgs} args - Arguments to create many Eventos.
     * @example
     * // Create many Eventos
     * const evento = await prisma.evento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Eventos and only return the `id`
     * const eventoWithIdOnly = await prisma.evento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventoCreateManyAndReturnArgs>(args?: SelectSubset<T, EventoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Evento.
     * @param {EventoDeleteArgs} args - Arguments to delete one Evento.
     * @example
     * // Delete one Evento
     * const Evento = await prisma.evento.delete({
     *   where: {
     *     // ... filter to delete one Evento
     *   }
     * })
     * 
     */
    delete<T extends EventoDeleteArgs>(args: SelectSubset<T, EventoDeleteArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Evento.
     * @param {EventoUpdateArgs} args - Arguments to update one Evento.
     * @example
     * // Update one Evento
     * const evento = await prisma.evento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventoUpdateArgs>(args: SelectSubset<T, EventoUpdateArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Eventos.
     * @param {EventoDeleteManyArgs} args - Arguments to filter Eventos to delete.
     * @example
     * // Delete a few Eventos
     * const { count } = await prisma.evento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventoDeleteManyArgs>(args?: SelectSubset<T, EventoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Eventos
     * const evento = await prisma.evento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventoUpdateManyArgs>(args: SelectSubset<T, EventoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Evento.
     * @param {EventoUpsertArgs} args - Arguments to update or create a Evento.
     * @example
     * // Update or create a Evento
     * const evento = await prisma.evento.upsert({
     *   create: {
     *     // ... data to create a Evento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evento we want to update
     *   }
     * })
     */
    upsert<T extends EventoUpsertArgs>(args: SelectSubset<T, EventoUpsertArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Eventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoCountArgs} args - Arguments to filter Eventos to count.
     * @example
     * // Count the number of Eventos
     * const count = await prisma.evento.count({
     *   where: {
     *     // ... the filter for the Eventos we want to count
     *   }
     * })
    **/
    count<T extends EventoCountArgs>(
      args?: Subset<T, EventoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventoAggregateArgs>(args: Subset<T, EventoAggregateArgs>): Prisma.PrismaPromise<GetEventoAggregateType<T>>

    /**
     * Group by Evento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventoGroupByArgs['orderBy'] }
        : { orderBy?: EventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evento model
   */
  readonly fields: EventoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participacoes<T extends Evento$participacoesArgs<ExtArgs> = {}>(args?: Subset<T, Evento$participacoesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "findMany"> | Null>
    comboios<T extends Evento$comboiosArgs<ExtArgs> = {}>(args?: Subset<T, Evento$comboiosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evento model
   */ 
  interface EventoFieldRefs {
    readonly id: FieldRef<"Evento", 'String'>
    readonly titulo: FieldRef<"Evento", 'String'>
    readonly descricao: FieldRef<"Evento", 'String'>
    readonly dataEvento: FieldRef<"Evento", 'DateTime'>
    readonly localEvento: FieldRef<"Evento", 'String'>
    readonly endereco: FieldRef<"Evento", 'String'>
    readonly latitude: FieldRef<"Evento", 'Float'>
    readonly longitude: FieldRef<"Evento", 'Float'>
    readonly participantesMaximo: FieldRef<"Evento", 'Int'>
    readonly valorInscricao: FieldRef<"Evento", 'Float'>
    readonly ativo: FieldRef<"Evento", 'Boolean'>
    readonly imagemUrl: FieldRef<"Evento", 'String'>
    readonly createdAt: FieldRef<"Evento", 'DateTime'>
    readonly updatedAt: FieldRef<"Evento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evento findUnique
   */
  export type EventoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento findUniqueOrThrow
   */
  export type EventoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento findFirst
   */
  export type EventoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eventos.
     */
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento findFirstOrThrow
   */
  export type EventoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Evento to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Eventos.
     */
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento findMany
   */
  export type EventoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter, which Eventos to fetch.
     */
    where?: EventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Eventos to fetch.
     */
    orderBy?: EventoOrderByWithRelationInput | EventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Eventos.
     */
    cursor?: EventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Eventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Eventos.
     */
    skip?: number
    distinct?: EventoScalarFieldEnum | EventoScalarFieldEnum[]
  }

  /**
   * Evento create
   */
  export type EventoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The data needed to create a Evento.
     */
    data: XOR<EventoCreateInput, EventoUncheckedCreateInput>
  }

  /**
   * Evento createMany
   */
  export type EventoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Eventos.
     */
    data: EventoCreateManyInput | EventoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evento createManyAndReturn
   */
  export type EventoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Eventos.
     */
    data: EventoCreateManyInput | EventoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evento update
   */
  export type EventoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The data needed to update a Evento.
     */
    data: XOR<EventoUpdateInput, EventoUncheckedUpdateInput>
    /**
     * Choose, which Evento to update.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento updateMany
   */
  export type EventoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Eventos.
     */
    data: XOR<EventoUpdateManyMutationInput, EventoUncheckedUpdateManyInput>
    /**
     * Filter which Eventos to update
     */
    where?: EventoWhereInput
  }

  /**
   * Evento upsert
   */
  export type EventoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * The filter to search for the Evento to update in case it exists.
     */
    where: EventoWhereUniqueInput
    /**
     * In case the Evento found by the `where` argument doesn't exist, create a new Evento with this data.
     */
    create: XOR<EventoCreateInput, EventoUncheckedCreateInput>
    /**
     * In case the Evento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventoUpdateInput, EventoUncheckedUpdateInput>
  }

  /**
   * Evento delete
   */
  export type EventoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
    /**
     * Filter which Evento to delete.
     */
    where: EventoWhereUniqueInput
  }

  /**
   * Evento deleteMany
   */
  export type EventoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Eventos to delete
     */
    where?: EventoWhereInput
  }

  /**
   * Evento.participacoes
   */
  export type Evento$participacoesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    where?: ParticipacaoEventoWhereInput
    orderBy?: ParticipacaoEventoOrderByWithRelationInput | ParticipacaoEventoOrderByWithRelationInput[]
    cursor?: ParticipacaoEventoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipacaoEventoScalarFieldEnum | ParticipacaoEventoScalarFieldEnum[]
  }

  /**
   * Evento.comboios
   */
  export type Evento$comboiosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    where?: ComboioEventoWhereInput
    orderBy?: ComboioEventoOrderByWithRelationInput | ComboioEventoOrderByWithRelationInput[]
    cursor?: ComboioEventoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComboioEventoScalarFieldEnum | ComboioEventoScalarFieldEnum[]
  }

  /**
   * Evento without action
   */
  export type EventoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evento
     */
    select?: EventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoInclude<ExtArgs> | null
  }


  /**
   * Model ParticipacaoEvento
   */

  export type AggregateParticipacaoEvento = {
    _count: ParticipacaoEventoCountAggregateOutputType | null
    _min: ParticipacaoEventoMinAggregateOutputType | null
    _max: ParticipacaoEventoMaxAggregateOutputType | null
  }

  export type ParticipacaoEventoMinAggregateOutputType = {
    id: string | null
    confirmado: boolean | null
    dataConfirmacao: Date | null
    observacoes: string | null
    userId: string | null
    eventoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParticipacaoEventoMaxAggregateOutputType = {
    id: string | null
    confirmado: boolean | null
    dataConfirmacao: Date | null
    observacoes: string | null
    userId: string | null
    eventoId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ParticipacaoEventoCountAggregateOutputType = {
    id: number
    confirmado: number
    dataConfirmacao: number
    observacoes: number
    userId: number
    eventoId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ParticipacaoEventoMinAggregateInputType = {
    id?: true
    confirmado?: true
    dataConfirmacao?: true
    observacoes?: true
    userId?: true
    eventoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParticipacaoEventoMaxAggregateInputType = {
    id?: true
    confirmado?: true
    dataConfirmacao?: true
    observacoes?: true
    userId?: true
    eventoId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ParticipacaoEventoCountAggregateInputType = {
    id?: true
    confirmado?: true
    dataConfirmacao?: true
    observacoes?: true
    userId?: true
    eventoId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ParticipacaoEventoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParticipacaoEvento to aggregate.
     */
    where?: ParticipacaoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParticipacaoEventos to fetch.
     */
    orderBy?: ParticipacaoEventoOrderByWithRelationInput | ParticipacaoEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParticipacaoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParticipacaoEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParticipacaoEventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ParticipacaoEventos
    **/
    _count?: true | ParticipacaoEventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParticipacaoEventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParticipacaoEventoMaxAggregateInputType
  }

  export type GetParticipacaoEventoAggregateType<T extends ParticipacaoEventoAggregateArgs> = {
        [P in keyof T & keyof AggregateParticipacaoEvento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipacaoEvento[P]>
      : GetScalarType<T[P], AggregateParticipacaoEvento[P]>
  }




  export type ParticipacaoEventoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipacaoEventoWhereInput
    orderBy?: ParticipacaoEventoOrderByWithAggregationInput | ParticipacaoEventoOrderByWithAggregationInput[]
    by: ParticipacaoEventoScalarFieldEnum[] | ParticipacaoEventoScalarFieldEnum
    having?: ParticipacaoEventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParticipacaoEventoCountAggregateInputType | true
    _min?: ParticipacaoEventoMinAggregateInputType
    _max?: ParticipacaoEventoMaxAggregateInputType
  }

  export type ParticipacaoEventoGroupByOutputType = {
    id: string
    confirmado: boolean
    dataConfirmacao: Date | null
    observacoes: string | null
    userId: string
    eventoId: string
    createdAt: Date
    updatedAt: Date
    _count: ParticipacaoEventoCountAggregateOutputType | null
    _min: ParticipacaoEventoMinAggregateOutputType | null
    _max: ParticipacaoEventoMaxAggregateOutputType | null
  }

  type GetParticipacaoEventoGroupByPayload<T extends ParticipacaoEventoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParticipacaoEventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParticipacaoEventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParticipacaoEventoGroupByOutputType[P]>
            : GetScalarType<T[P], ParticipacaoEventoGroupByOutputType[P]>
        }
      >
    >


  export type ParticipacaoEventoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    confirmado?: boolean
    dataConfirmacao?: boolean
    observacoes?: boolean
    userId?: boolean
    eventoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    evento?: boolean | EventoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participacaoEvento"]>

  export type ParticipacaoEventoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    confirmado?: boolean
    dataConfirmacao?: boolean
    observacoes?: boolean
    userId?: boolean
    eventoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    evento?: boolean | EventoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participacaoEvento"]>

  export type ParticipacaoEventoSelectScalar = {
    id?: boolean
    confirmado?: boolean
    dataConfirmacao?: boolean
    observacoes?: boolean
    userId?: boolean
    eventoId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ParticipacaoEventoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    evento?: boolean | EventoDefaultArgs<ExtArgs>
  }
  export type ParticipacaoEventoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    evento?: boolean | EventoDefaultArgs<ExtArgs>
  }

  export type $ParticipacaoEventoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ParticipacaoEvento"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      evento: Prisma.$EventoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      confirmado: boolean
      dataConfirmacao: Date | null
      observacoes: string | null
      userId: string
      eventoId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["participacaoEvento"]>
    composites: {}
  }

  type ParticipacaoEventoGetPayload<S extends boolean | null | undefined | ParticipacaoEventoDefaultArgs> = $Result.GetResult<Prisma.$ParticipacaoEventoPayload, S>

  type ParticipacaoEventoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ParticipacaoEventoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ParticipacaoEventoCountAggregateInputType | true
    }

  export interface ParticipacaoEventoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ParticipacaoEvento'], meta: { name: 'ParticipacaoEvento' } }
    /**
     * Find zero or one ParticipacaoEvento that matches the filter.
     * @param {ParticipacaoEventoFindUniqueArgs} args - Arguments to find a ParticipacaoEvento
     * @example
     * // Get one ParticipacaoEvento
     * const participacaoEvento = await prisma.participacaoEvento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParticipacaoEventoFindUniqueArgs>(args: SelectSubset<T, ParticipacaoEventoFindUniqueArgs<ExtArgs>>): Prisma__ParticipacaoEventoClient<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ParticipacaoEvento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ParticipacaoEventoFindUniqueOrThrowArgs} args - Arguments to find a ParticipacaoEvento
     * @example
     * // Get one ParticipacaoEvento
     * const participacaoEvento = await prisma.participacaoEvento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParticipacaoEventoFindUniqueOrThrowArgs>(args: SelectSubset<T, ParticipacaoEventoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParticipacaoEventoClient<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ParticipacaoEvento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacaoEventoFindFirstArgs} args - Arguments to find a ParticipacaoEvento
     * @example
     * // Get one ParticipacaoEvento
     * const participacaoEvento = await prisma.participacaoEvento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParticipacaoEventoFindFirstArgs>(args?: SelectSubset<T, ParticipacaoEventoFindFirstArgs<ExtArgs>>): Prisma__ParticipacaoEventoClient<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ParticipacaoEvento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacaoEventoFindFirstOrThrowArgs} args - Arguments to find a ParticipacaoEvento
     * @example
     * // Get one ParticipacaoEvento
     * const participacaoEvento = await prisma.participacaoEvento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParticipacaoEventoFindFirstOrThrowArgs>(args?: SelectSubset<T, ParticipacaoEventoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParticipacaoEventoClient<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ParticipacaoEventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacaoEventoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ParticipacaoEventos
     * const participacaoEventos = await prisma.participacaoEvento.findMany()
     * 
     * // Get first 10 ParticipacaoEventos
     * const participacaoEventos = await prisma.participacaoEvento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const participacaoEventoWithIdOnly = await prisma.participacaoEvento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParticipacaoEventoFindManyArgs>(args?: SelectSubset<T, ParticipacaoEventoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ParticipacaoEvento.
     * @param {ParticipacaoEventoCreateArgs} args - Arguments to create a ParticipacaoEvento.
     * @example
     * // Create one ParticipacaoEvento
     * const ParticipacaoEvento = await prisma.participacaoEvento.create({
     *   data: {
     *     // ... data to create a ParticipacaoEvento
     *   }
     * })
     * 
     */
    create<T extends ParticipacaoEventoCreateArgs>(args: SelectSubset<T, ParticipacaoEventoCreateArgs<ExtArgs>>): Prisma__ParticipacaoEventoClient<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ParticipacaoEventos.
     * @param {ParticipacaoEventoCreateManyArgs} args - Arguments to create many ParticipacaoEventos.
     * @example
     * // Create many ParticipacaoEventos
     * const participacaoEvento = await prisma.participacaoEvento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParticipacaoEventoCreateManyArgs>(args?: SelectSubset<T, ParticipacaoEventoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ParticipacaoEventos and returns the data saved in the database.
     * @param {ParticipacaoEventoCreateManyAndReturnArgs} args - Arguments to create many ParticipacaoEventos.
     * @example
     * // Create many ParticipacaoEventos
     * const participacaoEvento = await prisma.participacaoEvento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ParticipacaoEventos and only return the `id`
     * const participacaoEventoWithIdOnly = await prisma.participacaoEvento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParticipacaoEventoCreateManyAndReturnArgs>(args?: SelectSubset<T, ParticipacaoEventoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ParticipacaoEvento.
     * @param {ParticipacaoEventoDeleteArgs} args - Arguments to delete one ParticipacaoEvento.
     * @example
     * // Delete one ParticipacaoEvento
     * const ParticipacaoEvento = await prisma.participacaoEvento.delete({
     *   where: {
     *     // ... filter to delete one ParticipacaoEvento
     *   }
     * })
     * 
     */
    delete<T extends ParticipacaoEventoDeleteArgs>(args: SelectSubset<T, ParticipacaoEventoDeleteArgs<ExtArgs>>): Prisma__ParticipacaoEventoClient<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ParticipacaoEvento.
     * @param {ParticipacaoEventoUpdateArgs} args - Arguments to update one ParticipacaoEvento.
     * @example
     * // Update one ParticipacaoEvento
     * const participacaoEvento = await prisma.participacaoEvento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParticipacaoEventoUpdateArgs>(args: SelectSubset<T, ParticipacaoEventoUpdateArgs<ExtArgs>>): Prisma__ParticipacaoEventoClient<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ParticipacaoEventos.
     * @param {ParticipacaoEventoDeleteManyArgs} args - Arguments to filter ParticipacaoEventos to delete.
     * @example
     * // Delete a few ParticipacaoEventos
     * const { count } = await prisma.participacaoEvento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParticipacaoEventoDeleteManyArgs>(args?: SelectSubset<T, ParticipacaoEventoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ParticipacaoEventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacaoEventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ParticipacaoEventos
     * const participacaoEvento = await prisma.participacaoEvento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParticipacaoEventoUpdateManyArgs>(args: SelectSubset<T, ParticipacaoEventoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ParticipacaoEvento.
     * @param {ParticipacaoEventoUpsertArgs} args - Arguments to update or create a ParticipacaoEvento.
     * @example
     * // Update or create a ParticipacaoEvento
     * const participacaoEvento = await prisma.participacaoEvento.upsert({
     *   create: {
     *     // ... data to create a ParticipacaoEvento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ParticipacaoEvento we want to update
     *   }
     * })
     */
    upsert<T extends ParticipacaoEventoUpsertArgs>(args: SelectSubset<T, ParticipacaoEventoUpsertArgs<ExtArgs>>): Prisma__ParticipacaoEventoClient<$Result.GetResult<Prisma.$ParticipacaoEventoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ParticipacaoEventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacaoEventoCountArgs} args - Arguments to filter ParticipacaoEventos to count.
     * @example
     * // Count the number of ParticipacaoEventos
     * const count = await prisma.participacaoEvento.count({
     *   where: {
     *     // ... the filter for the ParticipacaoEventos we want to count
     *   }
     * })
    **/
    count<T extends ParticipacaoEventoCountArgs>(
      args?: Subset<T, ParticipacaoEventoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParticipacaoEventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ParticipacaoEvento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacaoEventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParticipacaoEventoAggregateArgs>(args: Subset<T, ParticipacaoEventoAggregateArgs>): Prisma.PrismaPromise<GetParticipacaoEventoAggregateType<T>>

    /**
     * Group by ParticipacaoEvento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacaoEventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParticipacaoEventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParticipacaoEventoGroupByArgs['orderBy'] }
        : { orderBy?: ParticipacaoEventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParticipacaoEventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParticipacaoEventoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ParticipacaoEvento model
   */
  readonly fields: ParticipacaoEventoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ParticipacaoEvento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParticipacaoEventoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    evento<T extends EventoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventoDefaultArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ParticipacaoEvento model
   */ 
  interface ParticipacaoEventoFieldRefs {
    readonly id: FieldRef<"ParticipacaoEvento", 'String'>
    readonly confirmado: FieldRef<"ParticipacaoEvento", 'Boolean'>
    readonly dataConfirmacao: FieldRef<"ParticipacaoEvento", 'DateTime'>
    readonly observacoes: FieldRef<"ParticipacaoEvento", 'String'>
    readonly userId: FieldRef<"ParticipacaoEvento", 'String'>
    readonly eventoId: FieldRef<"ParticipacaoEvento", 'String'>
    readonly createdAt: FieldRef<"ParticipacaoEvento", 'DateTime'>
    readonly updatedAt: FieldRef<"ParticipacaoEvento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ParticipacaoEvento findUnique
   */
  export type ParticipacaoEventoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    /**
     * Filter, which ParticipacaoEvento to fetch.
     */
    where: ParticipacaoEventoWhereUniqueInput
  }

  /**
   * ParticipacaoEvento findUniqueOrThrow
   */
  export type ParticipacaoEventoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    /**
     * Filter, which ParticipacaoEvento to fetch.
     */
    where: ParticipacaoEventoWhereUniqueInput
  }

  /**
   * ParticipacaoEvento findFirst
   */
  export type ParticipacaoEventoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    /**
     * Filter, which ParticipacaoEvento to fetch.
     */
    where?: ParticipacaoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParticipacaoEventos to fetch.
     */
    orderBy?: ParticipacaoEventoOrderByWithRelationInput | ParticipacaoEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParticipacaoEventos.
     */
    cursor?: ParticipacaoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParticipacaoEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParticipacaoEventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParticipacaoEventos.
     */
    distinct?: ParticipacaoEventoScalarFieldEnum | ParticipacaoEventoScalarFieldEnum[]
  }

  /**
   * ParticipacaoEvento findFirstOrThrow
   */
  export type ParticipacaoEventoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    /**
     * Filter, which ParticipacaoEvento to fetch.
     */
    where?: ParticipacaoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParticipacaoEventos to fetch.
     */
    orderBy?: ParticipacaoEventoOrderByWithRelationInput | ParticipacaoEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ParticipacaoEventos.
     */
    cursor?: ParticipacaoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParticipacaoEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParticipacaoEventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ParticipacaoEventos.
     */
    distinct?: ParticipacaoEventoScalarFieldEnum | ParticipacaoEventoScalarFieldEnum[]
  }

  /**
   * ParticipacaoEvento findMany
   */
  export type ParticipacaoEventoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    /**
     * Filter, which ParticipacaoEventos to fetch.
     */
    where?: ParticipacaoEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ParticipacaoEventos to fetch.
     */
    orderBy?: ParticipacaoEventoOrderByWithRelationInput | ParticipacaoEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ParticipacaoEventos.
     */
    cursor?: ParticipacaoEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ParticipacaoEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ParticipacaoEventos.
     */
    skip?: number
    distinct?: ParticipacaoEventoScalarFieldEnum | ParticipacaoEventoScalarFieldEnum[]
  }

  /**
   * ParticipacaoEvento create
   */
  export type ParticipacaoEventoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    /**
     * The data needed to create a ParticipacaoEvento.
     */
    data: XOR<ParticipacaoEventoCreateInput, ParticipacaoEventoUncheckedCreateInput>
  }

  /**
   * ParticipacaoEvento createMany
   */
  export type ParticipacaoEventoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ParticipacaoEventos.
     */
    data: ParticipacaoEventoCreateManyInput | ParticipacaoEventoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ParticipacaoEvento createManyAndReturn
   */
  export type ParticipacaoEventoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ParticipacaoEventos.
     */
    data: ParticipacaoEventoCreateManyInput | ParticipacaoEventoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ParticipacaoEvento update
   */
  export type ParticipacaoEventoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    /**
     * The data needed to update a ParticipacaoEvento.
     */
    data: XOR<ParticipacaoEventoUpdateInput, ParticipacaoEventoUncheckedUpdateInput>
    /**
     * Choose, which ParticipacaoEvento to update.
     */
    where: ParticipacaoEventoWhereUniqueInput
  }

  /**
   * ParticipacaoEvento updateMany
   */
  export type ParticipacaoEventoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ParticipacaoEventos.
     */
    data: XOR<ParticipacaoEventoUpdateManyMutationInput, ParticipacaoEventoUncheckedUpdateManyInput>
    /**
     * Filter which ParticipacaoEventos to update
     */
    where?: ParticipacaoEventoWhereInput
  }

  /**
   * ParticipacaoEvento upsert
   */
  export type ParticipacaoEventoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    /**
     * The filter to search for the ParticipacaoEvento to update in case it exists.
     */
    where: ParticipacaoEventoWhereUniqueInput
    /**
     * In case the ParticipacaoEvento found by the `where` argument doesn't exist, create a new ParticipacaoEvento with this data.
     */
    create: XOR<ParticipacaoEventoCreateInput, ParticipacaoEventoUncheckedCreateInput>
    /**
     * In case the ParticipacaoEvento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParticipacaoEventoUpdateInput, ParticipacaoEventoUncheckedUpdateInput>
  }

  /**
   * ParticipacaoEvento delete
   */
  export type ParticipacaoEventoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
    /**
     * Filter which ParticipacaoEvento to delete.
     */
    where: ParticipacaoEventoWhereUniqueInput
  }

  /**
   * ParticipacaoEvento deleteMany
   */
  export type ParticipacaoEventoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ParticipacaoEventos to delete
     */
    where?: ParticipacaoEventoWhereInput
  }

  /**
   * ParticipacaoEvento without action
   */
  export type ParticipacaoEventoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacaoEvento
     */
    select?: ParticipacaoEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacaoEventoInclude<ExtArgs> | null
  }


  /**
   * Model ComboioEvento
   */

  export type AggregateComboioEvento = {
    _count: ComboioEventoCountAggregateOutputType | null
    _avg: ComboioEventoAvgAggregateOutputType | null
    _sum: ComboioEventoSumAggregateOutputType | null
    _min: ComboioEventoMinAggregateOutputType | null
    _max: ComboioEventoMaxAggregateOutputType | null
  }

  export type ComboioEventoAvgAggregateOutputType = {
    vagas: number | null
  }

  export type ComboioEventoSumAggregateOutputType = {
    vagas: number | null
  }

  export type ComboioEventoMinAggregateOutputType = {
    id: string | null
    nome: string | null
    descricao: string | null
    pontoEncontro: string | null
    horarioSaida: Date | null
    vagas: number | null
    ativo: boolean | null
    eventoId: string | null
    liderUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComboioEventoMaxAggregateOutputType = {
    id: string | null
    nome: string | null
    descricao: string | null
    pontoEncontro: string | null
    horarioSaida: Date | null
    vagas: number | null
    ativo: boolean | null
    eventoId: string | null
    liderUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComboioEventoCountAggregateOutputType = {
    id: number
    nome: number
    descricao: number
    pontoEncontro: number
    horarioSaida: number
    vagas: number
    ativo: number
    eventoId: number
    liderUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComboioEventoAvgAggregateInputType = {
    vagas?: true
  }

  export type ComboioEventoSumAggregateInputType = {
    vagas?: true
  }

  export type ComboioEventoMinAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    pontoEncontro?: true
    horarioSaida?: true
    vagas?: true
    ativo?: true
    eventoId?: true
    liderUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComboioEventoMaxAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    pontoEncontro?: true
    horarioSaida?: true
    vagas?: true
    ativo?: true
    eventoId?: true
    liderUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComboioEventoCountAggregateInputType = {
    id?: true
    nome?: true
    descricao?: true
    pontoEncontro?: true
    horarioSaida?: true
    vagas?: true
    ativo?: true
    eventoId?: true
    liderUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComboioEventoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComboioEvento to aggregate.
     */
    where?: ComboioEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboioEventos to fetch.
     */
    orderBy?: ComboioEventoOrderByWithRelationInput | ComboioEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComboioEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboioEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboioEventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComboioEventos
    **/
    _count?: true | ComboioEventoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComboioEventoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComboioEventoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComboioEventoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComboioEventoMaxAggregateInputType
  }

  export type GetComboioEventoAggregateType<T extends ComboioEventoAggregateArgs> = {
        [P in keyof T & keyof AggregateComboioEvento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComboioEvento[P]>
      : GetScalarType<T[P], AggregateComboioEvento[P]>
  }




  export type ComboioEventoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComboioEventoWhereInput
    orderBy?: ComboioEventoOrderByWithAggregationInput | ComboioEventoOrderByWithAggregationInput[]
    by: ComboioEventoScalarFieldEnum[] | ComboioEventoScalarFieldEnum
    having?: ComboioEventoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComboioEventoCountAggregateInputType | true
    _avg?: ComboioEventoAvgAggregateInputType
    _sum?: ComboioEventoSumAggregateInputType
    _min?: ComboioEventoMinAggregateInputType
    _max?: ComboioEventoMaxAggregateInputType
  }

  export type ComboioEventoGroupByOutputType = {
    id: string
    nome: string
    descricao: string | null
    pontoEncontro: string
    horarioSaida: Date
    vagas: number
    ativo: boolean
    eventoId: string
    liderUserId: string
    createdAt: Date
    updatedAt: Date
    _count: ComboioEventoCountAggregateOutputType | null
    _avg: ComboioEventoAvgAggregateOutputType | null
    _sum: ComboioEventoSumAggregateOutputType | null
    _min: ComboioEventoMinAggregateOutputType | null
    _max: ComboioEventoMaxAggregateOutputType | null
  }

  type GetComboioEventoGroupByPayload<T extends ComboioEventoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComboioEventoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComboioEventoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComboioEventoGroupByOutputType[P]>
            : GetScalarType<T[P], ComboioEventoGroupByOutputType[P]>
        }
      >
    >


  export type ComboioEventoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    pontoEncontro?: boolean
    horarioSaida?: boolean
    vagas?: boolean
    ativo?: boolean
    eventoId?: boolean
    liderUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evento?: boolean | EventoDefaultArgs<ExtArgs>
    lider?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comboioEvento"]>

  export type ComboioEventoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nome?: boolean
    descricao?: boolean
    pontoEncontro?: boolean
    horarioSaida?: boolean
    vagas?: boolean
    ativo?: boolean
    eventoId?: boolean
    liderUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    evento?: boolean | EventoDefaultArgs<ExtArgs>
    lider?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comboioEvento"]>

  export type ComboioEventoSelectScalar = {
    id?: boolean
    nome?: boolean
    descricao?: boolean
    pontoEncontro?: boolean
    horarioSaida?: boolean
    vagas?: boolean
    ativo?: boolean
    eventoId?: boolean
    liderUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComboioEventoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evento?: boolean | EventoDefaultArgs<ExtArgs>
    lider?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ComboioEventoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evento?: boolean | EventoDefaultArgs<ExtArgs>
    lider?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ComboioEventoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComboioEvento"
    objects: {
      evento: Prisma.$EventoPayload<ExtArgs>
      lider: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nome: string
      descricao: string | null
      pontoEncontro: string
      horarioSaida: Date
      vagas: number
      ativo: boolean
      eventoId: string
      liderUserId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comboioEvento"]>
    composites: {}
  }

  type ComboioEventoGetPayload<S extends boolean | null | undefined | ComboioEventoDefaultArgs> = $Result.GetResult<Prisma.$ComboioEventoPayload, S>

  type ComboioEventoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ComboioEventoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ComboioEventoCountAggregateInputType | true
    }

  export interface ComboioEventoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComboioEvento'], meta: { name: 'ComboioEvento' } }
    /**
     * Find zero or one ComboioEvento that matches the filter.
     * @param {ComboioEventoFindUniqueArgs} args - Arguments to find a ComboioEvento
     * @example
     * // Get one ComboioEvento
     * const comboioEvento = await prisma.comboioEvento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComboioEventoFindUniqueArgs>(args: SelectSubset<T, ComboioEventoFindUniqueArgs<ExtArgs>>): Prisma__ComboioEventoClient<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ComboioEvento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ComboioEventoFindUniqueOrThrowArgs} args - Arguments to find a ComboioEvento
     * @example
     * // Get one ComboioEvento
     * const comboioEvento = await prisma.comboioEvento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComboioEventoFindUniqueOrThrowArgs>(args: SelectSubset<T, ComboioEventoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComboioEventoClient<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ComboioEvento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboioEventoFindFirstArgs} args - Arguments to find a ComboioEvento
     * @example
     * // Get one ComboioEvento
     * const comboioEvento = await prisma.comboioEvento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComboioEventoFindFirstArgs>(args?: SelectSubset<T, ComboioEventoFindFirstArgs<ExtArgs>>): Prisma__ComboioEventoClient<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ComboioEvento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboioEventoFindFirstOrThrowArgs} args - Arguments to find a ComboioEvento
     * @example
     * // Get one ComboioEvento
     * const comboioEvento = await prisma.comboioEvento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComboioEventoFindFirstOrThrowArgs>(args?: SelectSubset<T, ComboioEventoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComboioEventoClient<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ComboioEventos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboioEventoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComboioEventos
     * const comboioEventos = await prisma.comboioEvento.findMany()
     * 
     * // Get first 10 ComboioEventos
     * const comboioEventos = await prisma.comboioEvento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const comboioEventoWithIdOnly = await prisma.comboioEvento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComboioEventoFindManyArgs>(args?: SelectSubset<T, ComboioEventoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ComboioEvento.
     * @param {ComboioEventoCreateArgs} args - Arguments to create a ComboioEvento.
     * @example
     * // Create one ComboioEvento
     * const ComboioEvento = await prisma.comboioEvento.create({
     *   data: {
     *     // ... data to create a ComboioEvento
     *   }
     * })
     * 
     */
    create<T extends ComboioEventoCreateArgs>(args: SelectSubset<T, ComboioEventoCreateArgs<ExtArgs>>): Prisma__ComboioEventoClient<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ComboioEventos.
     * @param {ComboioEventoCreateManyArgs} args - Arguments to create many ComboioEventos.
     * @example
     * // Create many ComboioEventos
     * const comboioEvento = await prisma.comboioEvento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComboioEventoCreateManyArgs>(args?: SelectSubset<T, ComboioEventoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComboioEventos and returns the data saved in the database.
     * @param {ComboioEventoCreateManyAndReturnArgs} args - Arguments to create many ComboioEventos.
     * @example
     * // Create many ComboioEventos
     * const comboioEvento = await prisma.comboioEvento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComboioEventos and only return the `id`
     * const comboioEventoWithIdOnly = await prisma.comboioEvento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComboioEventoCreateManyAndReturnArgs>(args?: SelectSubset<T, ComboioEventoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ComboioEvento.
     * @param {ComboioEventoDeleteArgs} args - Arguments to delete one ComboioEvento.
     * @example
     * // Delete one ComboioEvento
     * const ComboioEvento = await prisma.comboioEvento.delete({
     *   where: {
     *     // ... filter to delete one ComboioEvento
     *   }
     * })
     * 
     */
    delete<T extends ComboioEventoDeleteArgs>(args: SelectSubset<T, ComboioEventoDeleteArgs<ExtArgs>>): Prisma__ComboioEventoClient<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ComboioEvento.
     * @param {ComboioEventoUpdateArgs} args - Arguments to update one ComboioEvento.
     * @example
     * // Update one ComboioEvento
     * const comboioEvento = await prisma.comboioEvento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComboioEventoUpdateArgs>(args: SelectSubset<T, ComboioEventoUpdateArgs<ExtArgs>>): Prisma__ComboioEventoClient<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ComboioEventos.
     * @param {ComboioEventoDeleteManyArgs} args - Arguments to filter ComboioEventos to delete.
     * @example
     * // Delete a few ComboioEventos
     * const { count } = await prisma.comboioEvento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComboioEventoDeleteManyArgs>(args?: SelectSubset<T, ComboioEventoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComboioEventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboioEventoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComboioEventos
     * const comboioEvento = await prisma.comboioEvento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComboioEventoUpdateManyArgs>(args: SelectSubset<T, ComboioEventoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ComboioEvento.
     * @param {ComboioEventoUpsertArgs} args - Arguments to update or create a ComboioEvento.
     * @example
     * // Update or create a ComboioEvento
     * const comboioEvento = await prisma.comboioEvento.upsert({
     *   create: {
     *     // ... data to create a ComboioEvento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComboioEvento we want to update
     *   }
     * })
     */
    upsert<T extends ComboioEventoUpsertArgs>(args: SelectSubset<T, ComboioEventoUpsertArgs<ExtArgs>>): Prisma__ComboioEventoClient<$Result.GetResult<Prisma.$ComboioEventoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ComboioEventos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboioEventoCountArgs} args - Arguments to filter ComboioEventos to count.
     * @example
     * // Count the number of ComboioEventos
     * const count = await prisma.comboioEvento.count({
     *   where: {
     *     // ... the filter for the ComboioEventos we want to count
     *   }
     * })
    **/
    count<T extends ComboioEventoCountArgs>(
      args?: Subset<T, ComboioEventoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComboioEventoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComboioEvento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboioEventoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComboioEventoAggregateArgs>(args: Subset<T, ComboioEventoAggregateArgs>): Prisma.PrismaPromise<GetComboioEventoAggregateType<T>>

    /**
     * Group by ComboioEvento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComboioEventoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComboioEventoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComboioEventoGroupByArgs['orderBy'] }
        : { orderBy?: ComboioEventoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComboioEventoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComboioEventoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComboioEvento model
   */
  readonly fields: ComboioEventoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComboioEvento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComboioEventoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evento<T extends EventoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventoDefaultArgs<ExtArgs>>): Prisma__EventoClient<$Result.GetResult<Prisma.$EventoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    lider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComboioEvento model
   */ 
  interface ComboioEventoFieldRefs {
    readonly id: FieldRef<"ComboioEvento", 'String'>
    readonly nome: FieldRef<"ComboioEvento", 'String'>
    readonly descricao: FieldRef<"ComboioEvento", 'String'>
    readonly pontoEncontro: FieldRef<"ComboioEvento", 'String'>
    readonly horarioSaida: FieldRef<"ComboioEvento", 'DateTime'>
    readonly vagas: FieldRef<"ComboioEvento", 'Int'>
    readonly ativo: FieldRef<"ComboioEvento", 'Boolean'>
    readonly eventoId: FieldRef<"ComboioEvento", 'String'>
    readonly liderUserId: FieldRef<"ComboioEvento", 'String'>
    readonly createdAt: FieldRef<"ComboioEvento", 'DateTime'>
    readonly updatedAt: FieldRef<"ComboioEvento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComboioEvento findUnique
   */
  export type ComboioEventoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    /**
     * Filter, which ComboioEvento to fetch.
     */
    where: ComboioEventoWhereUniqueInput
  }

  /**
   * ComboioEvento findUniqueOrThrow
   */
  export type ComboioEventoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    /**
     * Filter, which ComboioEvento to fetch.
     */
    where: ComboioEventoWhereUniqueInput
  }

  /**
   * ComboioEvento findFirst
   */
  export type ComboioEventoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    /**
     * Filter, which ComboioEvento to fetch.
     */
    where?: ComboioEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboioEventos to fetch.
     */
    orderBy?: ComboioEventoOrderByWithRelationInput | ComboioEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComboioEventos.
     */
    cursor?: ComboioEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboioEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboioEventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComboioEventos.
     */
    distinct?: ComboioEventoScalarFieldEnum | ComboioEventoScalarFieldEnum[]
  }

  /**
   * ComboioEvento findFirstOrThrow
   */
  export type ComboioEventoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    /**
     * Filter, which ComboioEvento to fetch.
     */
    where?: ComboioEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboioEventos to fetch.
     */
    orderBy?: ComboioEventoOrderByWithRelationInput | ComboioEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComboioEventos.
     */
    cursor?: ComboioEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboioEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboioEventos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComboioEventos.
     */
    distinct?: ComboioEventoScalarFieldEnum | ComboioEventoScalarFieldEnum[]
  }

  /**
   * ComboioEvento findMany
   */
  export type ComboioEventoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    /**
     * Filter, which ComboioEventos to fetch.
     */
    where?: ComboioEventoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComboioEventos to fetch.
     */
    orderBy?: ComboioEventoOrderByWithRelationInput | ComboioEventoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComboioEventos.
     */
    cursor?: ComboioEventoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComboioEventos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComboioEventos.
     */
    skip?: number
    distinct?: ComboioEventoScalarFieldEnum | ComboioEventoScalarFieldEnum[]
  }

  /**
   * ComboioEvento create
   */
  export type ComboioEventoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    /**
     * The data needed to create a ComboioEvento.
     */
    data: XOR<ComboioEventoCreateInput, ComboioEventoUncheckedCreateInput>
  }

  /**
   * ComboioEvento createMany
   */
  export type ComboioEventoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComboioEventos.
     */
    data: ComboioEventoCreateManyInput | ComboioEventoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComboioEvento createManyAndReturn
   */
  export type ComboioEventoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ComboioEventos.
     */
    data: ComboioEventoCreateManyInput | ComboioEventoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComboioEvento update
   */
  export type ComboioEventoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    /**
     * The data needed to update a ComboioEvento.
     */
    data: XOR<ComboioEventoUpdateInput, ComboioEventoUncheckedUpdateInput>
    /**
     * Choose, which ComboioEvento to update.
     */
    where: ComboioEventoWhereUniqueInput
  }

  /**
   * ComboioEvento updateMany
   */
  export type ComboioEventoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComboioEventos.
     */
    data: XOR<ComboioEventoUpdateManyMutationInput, ComboioEventoUncheckedUpdateManyInput>
    /**
     * Filter which ComboioEventos to update
     */
    where?: ComboioEventoWhereInput
  }

  /**
   * ComboioEvento upsert
   */
  export type ComboioEventoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    /**
     * The filter to search for the ComboioEvento to update in case it exists.
     */
    where: ComboioEventoWhereUniqueInput
    /**
     * In case the ComboioEvento found by the `where` argument doesn't exist, create a new ComboioEvento with this data.
     */
    create: XOR<ComboioEventoCreateInput, ComboioEventoUncheckedCreateInput>
    /**
     * In case the ComboioEvento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComboioEventoUpdateInput, ComboioEventoUncheckedUpdateInput>
  }

  /**
   * ComboioEvento delete
   */
  export type ComboioEventoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
    /**
     * Filter which ComboioEvento to delete.
     */
    where: ComboioEventoWhereUniqueInput
  }

  /**
   * ComboioEvento deleteMany
   */
  export type ComboioEventoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComboioEventos to delete
     */
    where?: ComboioEventoWhereInput
  }

  /**
   * ComboioEvento without action
   */
  export type ComboioEventoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComboioEvento
     */
    select?: ComboioEventoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComboioEventoInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    nomeCompleto: 'nomeCompleto',
    telefone: 'telefone',
    cidade: 'cidade',
    estado: 'estado',
    dataNascimento: 'dataNascimento',
    tipoUsuario: 'tipoUsuario',
    ativo: 'ativo',
    emailVerificado: 'emailVerificado',
    avatarUrl: 'avatarUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FamiliarScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    parentesco: 'parentesco',
    idade: 'idade',
    telefone: 'telefone',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FamiliarScalarFieldEnum = (typeof FamiliarScalarFieldEnum)[keyof typeof FamiliarScalarFieldEnum]


  export const PremioScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descricao: 'descricao',
    categoria: 'categoria',
    ano: 'ano',
    posicao: 'posicao',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PremioScalarFieldEnum = (typeof PremioScalarFieldEnum)[keyof typeof PremioScalarFieldEnum]


  export const MotoScalarFieldEnum: {
    id: 'id',
    marca: 'marca',
    modelo: 'modelo',
    ano: 'ano',
    cor: 'cor',
    cilindrada: 'cilindrada',
    placa: 'placa',
    principal: 'principal',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MotoScalarFieldEnum = (typeof MotoScalarFieldEnum)[keyof typeof MotoScalarFieldEnum]


  export const EventoScalarFieldEnum: {
    id: 'id',
    titulo: 'titulo',
    descricao: 'descricao',
    dataEvento: 'dataEvento',
    localEvento: 'localEvento',
    endereco: 'endereco',
    latitude: 'latitude',
    longitude: 'longitude',
    participantesMaximo: 'participantesMaximo',
    valorInscricao: 'valorInscricao',
    ativo: 'ativo',
    imagemUrl: 'imagemUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventoScalarFieldEnum = (typeof EventoScalarFieldEnum)[keyof typeof EventoScalarFieldEnum]


  export const ParticipacaoEventoScalarFieldEnum: {
    id: 'id',
    confirmado: 'confirmado',
    dataConfirmacao: 'dataConfirmacao',
    observacoes: 'observacoes',
    userId: 'userId',
    eventoId: 'eventoId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ParticipacaoEventoScalarFieldEnum = (typeof ParticipacaoEventoScalarFieldEnum)[keyof typeof ParticipacaoEventoScalarFieldEnum]


  export const ComboioEventoScalarFieldEnum: {
    id: 'id',
    nome: 'nome',
    descricao: 'descricao',
    pontoEncontro: 'pontoEncontro',
    horarioSaida: 'horarioSaida',
    vagas: 'vagas',
    ativo: 'ativo',
    eventoId: 'eventoId',
    liderUserId: 'liderUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComboioEventoScalarFieldEnum = (typeof ComboioEventoScalarFieldEnum)[keyof typeof ComboioEventoScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    nomeCompleto?: StringFilter<"User"> | string
    telefone?: StringNullableFilter<"User"> | string | null
    cidade?: StringNullableFilter<"User"> | string | null
    estado?: StringNullableFilter<"User"> | string | null
    dataNascimento?: DateTimeNullableFilter<"User"> | Date | string | null
    tipoUsuario?: EnumUserTypeFilter<"User"> | $Enums.UserType
    ativo?: BoolFilter<"User"> | boolean
    emailVerificado?: BoolFilter<"User"> | boolean
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    familiares?: FamiliarListRelationFilter
    premios?: PremioListRelationFilter
    motos?: MotoListRelationFilter
    participacoes?: ParticipacaoEventoListRelationFilter
    comboiosLiderados?: ComboioEventoListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nomeCompleto?: SortOrder
    telefone?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    dataNascimento?: SortOrderInput | SortOrder
    tipoUsuario?: SortOrder
    ativo?: SortOrder
    emailVerificado?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    familiares?: FamiliarOrderByRelationAggregateInput
    premios?: PremioOrderByRelationAggregateInput
    motos?: MotoOrderByRelationAggregateInput
    participacoes?: ParticipacaoEventoOrderByRelationAggregateInput
    comboiosLiderados?: ComboioEventoOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    nomeCompleto?: StringFilter<"User"> | string
    telefone?: StringNullableFilter<"User"> | string | null
    cidade?: StringNullableFilter<"User"> | string | null
    estado?: StringNullableFilter<"User"> | string | null
    dataNascimento?: DateTimeNullableFilter<"User"> | Date | string | null
    tipoUsuario?: EnumUserTypeFilter<"User"> | $Enums.UserType
    ativo?: BoolFilter<"User"> | boolean
    emailVerificado?: BoolFilter<"User"> | boolean
    avatarUrl?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    familiares?: FamiliarListRelationFilter
    premios?: PremioListRelationFilter
    motos?: MotoListRelationFilter
    participacoes?: ParticipacaoEventoListRelationFilter
    comboiosLiderados?: ComboioEventoListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nomeCompleto?: SortOrder
    telefone?: SortOrderInput | SortOrder
    cidade?: SortOrderInput | SortOrder
    estado?: SortOrderInput | SortOrder
    dataNascimento?: SortOrderInput | SortOrder
    tipoUsuario?: SortOrder
    ativo?: SortOrder
    emailVerificado?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    nomeCompleto?: StringWithAggregatesFilter<"User"> | string
    telefone?: StringNullableWithAggregatesFilter<"User"> | string | null
    cidade?: StringNullableWithAggregatesFilter<"User"> | string | null
    estado?: StringNullableWithAggregatesFilter<"User"> | string | null
    dataNascimento?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    tipoUsuario?: EnumUserTypeWithAggregatesFilter<"User"> | $Enums.UserType
    ativo?: BoolWithAggregatesFilter<"User"> | boolean
    emailVerificado?: BoolWithAggregatesFilter<"User"> | boolean
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type FamiliarWhereInput = {
    AND?: FamiliarWhereInput | FamiliarWhereInput[]
    OR?: FamiliarWhereInput[]
    NOT?: FamiliarWhereInput | FamiliarWhereInput[]
    id?: StringFilter<"Familiar"> | string
    nome?: StringFilter<"Familiar"> | string
    parentesco?: StringFilter<"Familiar"> | string
    idade?: IntNullableFilter<"Familiar"> | number | null
    telefone?: StringNullableFilter<"Familiar"> | string | null
    userId?: StringFilter<"Familiar"> | string
    createdAt?: DateTimeFilter<"Familiar"> | Date | string
    updatedAt?: DateTimeFilter<"Familiar"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type FamiliarOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    parentesco?: SortOrder
    idade?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type FamiliarWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FamiliarWhereInput | FamiliarWhereInput[]
    OR?: FamiliarWhereInput[]
    NOT?: FamiliarWhereInput | FamiliarWhereInput[]
    nome?: StringFilter<"Familiar"> | string
    parentesco?: StringFilter<"Familiar"> | string
    idade?: IntNullableFilter<"Familiar"> | number | null
    telefone?: StringNullableFilter<"Familiar"> | string | null
    userId?: StringFilter<"Familiar"> | string
    createdAt?: DateTimeFilter<"Familiar"> | Date | string
    updatedAt?: DateTimeFilter<"Familiar"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type FamiliarOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    parentesco?: SortOrder
    idade?: SortOrderInput | SortOrder
    telefone?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FamiliarCountOrderByAggregateInput
    _avg?: FamiliarAvgOrderByAggregateInput
    _max?: FamiliarMaxOrderByAggregateInput
    _min?: FamiliarMinOrderByAggregateInput
    _sum?: FamiliarSumOrderByAggregateInput
  }

  export type FamiliarScalarWhereWithAggregatesInput = {
    AND?: FamiliarScalarWhereWithAggregatesInput | FamiliarScalarWhereWithAggregatesInput[]
    OR?: FamiliarScalarWhereWithAggregatesInput[]
    NOT?: FamiliarScalarWhereWithAggregatesInput | FamiliarScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Familiar"> | string
    nome?: StringWithAggregatesFilter<"Familiar"> | string
    parentesco?: StringWithAggregatesFilter<"Familiar"> | string
    idade?: IntNullableWithAggregatesFilter<"Familiar"> | number | null
    telefone?: StringNullableWithAggregatesFilter<"Familiar"> | string | null
    userId?: StringWithAggregatesFilter<"Familiar"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Familiar"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Familiar"> | Date | string
  }

  export type PremioWhereInput = {
    AND?: PremioWhereInput | PremioWhereInput[]
    OR?: PremioWhereInput[]
    NOT?: PremioWhereInput | PremioWhereInput[]
    id?: StringFilter<"Premio"> | string
    titulo?: StringFilter<"Premio"> | string
    descricao?: StringNullableFilter<"Premio"> | string | null
    categoria?: StringFilter<"Premio"> | string
    ano?: IntFilter<"Premio"> | number
    posicao?: StringNullableFilter<"Premio"> | string | null
    userId?: StringFilter<"Premio"> | string
    createdAt?: DateTimeFilter<"Premio"> | Date | string
    updatedAt?: DateTimeFilter<"Premio"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PremioOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrderInput | SortOrder
    categoria?: SortOrder
    ano?: SortOrder
    posicao?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PremioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PremioWhereInput | PremioWhereInput[]
    OR?: PremioWhereInput[]
    NOT?: PremioWhereInput | PremioWhereInput[]
    titulo?: StringFilter<"Premio"> | string
    descricao?: StringNullableFilter<"Premio"> | string | null
    categoria?: StringFilter<"Premio"> | string
    ano?: IntFilter<"Premio"> | number
    posicao?: StringNullableFilter<"Premio"> | string | null
    userId?: StringFilter<"Premio"> | string
    createdAt?: DateTimeFilter<"Premio"> | Date | string
    updatedAt?: DateTimeFilter<"Premio"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PremioOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrderInput | SortOrder
    categoria?: SortOrder
    ano?: SortOrder
    posicao?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PremioCountOrderByAggregateInput
    _avg?: PremioAvgOrderByAggregateInput
    _max?: PremioMaxOrderByAggregateInput
    _min?: PremioMinOrderByAggregateInput
    _sum?: PremioSumOrderByAggregateInput
  }

  export type PremioScalarWhereWithAggregatesInput = {
    AND?: PremioScalarWhereWithAggregatesInput | PremioScalarWhereWithAggregatesInput[]
    OR?: PremioScalarWhereWithAggregatesInput[]
    NOT?: PremioScalarWhereWithAggregatesInput | PremioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Premio"> | string
    titulo?: StringWithAggregatesFilter<"Premio"> | string
    descricao?: StringNullableWithAggregatesFilter<"Premio"> | string | null
    categoria?: StringWithAggregatesFilter<"Premio"> | string
    ano?: IntWithAggregatesFilter<"Premio"> | number
    posicao?: StringNullableWithAggregatesFilter<"Premio"> | string | null
    userId?: StringWithAggregatesFilter<"Premio"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Premio"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Premio"> | Date | string
  }

  export type MotoWhereInput = {
    AND?: MotoWhereInput | MotoWhereInput[]
    OR?: MotoWhereInput[]
    NOT?: MotoWhereInput | MotoWhereInput[]
    id?: StringFilter<"Moto"> | string
    marca?: StringFilter<"Moto"> | string
    modelo?: StringFilter<"Moto"> | string
    ano?: IntFilter<"Moto"> | number
    cor?: StringFilter<"Moto"> | string
    cilindrada?: StringFilter<"Moto"> | string
    placa?: StringNullableFilter<"Moto"> | string | null
    principal?: BoolFilter<"Moto"> | boolean
    userId?: StringFilter<"Moto"> | string
    createdAt?: DateTimeFilter<"Moto"> | Date | string
    updatedAt?: DateTimeFilter<"Moto"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type MotoOrderByWithRelationInput = {
    id?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    ano?: SortOrder
    cor?: SortOrder
    cilindrada?: SortOrder
    placa?: SortOrderInput | SortOrder
    principal?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MotoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MotoWhereInput | MotoWhereInput[]
    OR?: MotoWhereInput[]
    NOT?: MotoWhereInput | MotoWhereInput[]
    marca?: StringFilter<"Moto"> | string
    modelo?: StringFilter<"Moto"> | string
    ano?: IntFilter<"Moto"> | number
    cor?: StringFilter<"Moto"> | string
    cilindrada?: StringFilter<"Moto"> | string
    placa?: StringNullableFilter<"Moto"> | string | null
    principal?: BoolFilter<"Moto"> | boolean
    userId?: StringFilter<"Moto"> | string
    createdAt?: DateTimeFilter<"Moto"> | Date | string
    updatedAt?: DateTimeFilter<"Moto"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type MotoOrderByWithAggregationInput = {
    id?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    ano?: SortOrder
    cor?: SortOrder
    cilindrada?: SortOrder
    placa?: SortOrderInput | SortOrder
    principal?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MotoCountOrderByAggregateInput
    _avg?: MotoAvgOrderByAggregateInput
    _max?: MotoMaxOrderByAggregateInput
    _min?: MotoMinOrderByAggregateInput
    _sum?: MotoSumOrderByAggregateInput
  }

  export type MotoScalarWhereWithAggregatesInput = {
    AND?: MotoScalarWhereWithAggregatesInput | MotoScalarWhereWithAggregatesInput[]
    OR?: MotoScalarWhereWithAggregatesInput[]
    NOT?: MotoScalarWhereWithAggregatesInput | MotoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Moto"> | string
    marca?: StringWithAggregatesFilter<"Moto"> | string
    modelo?: StringWithAggregatesFilter<"Moto"> | string
    ano?: IntWithAggregatesFilter<"Moto"> | number
    cor?: StringWithAggregatesFilter<"Moto"> | string
    cilindrada?: StringWithAggregatesFilter<"Moto"> | string
    placa?: StringNullableWithAggregatesFilter<"Moto"> | string | null
    principal?: BoolWithAggregatesFilter<"Moto"> | boolean
    userId?: StringWithAggregatesFilter<"Moto"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Moto"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Moto"> | Date | string
  }

  export type EventoWhereInput = {
    AND?: EventoWhereInput | EventoWhereInput[]
    OR?: EventoWhereInput[]
    NOT?: EventoWhereInput | EventoWhereInput[]
    id?: StringFilter<"Evento"> | string
    titulo?: StringFilter<"Evento"> | string
    descricao?: StringFilter<"Evento"> | string
    dataEvento?: DateTimeFilter<"Evento"> | Date | string
    localEvento?: StringFilter<"Evento"> | string
    endereco?: StringFilter<"Evento"> | string
    latitude?: FloatNullableFilter<"Evento"> | number | null
    longitude?: FloatNullableFilter<"Evento"> | number | null
    participantesMaximo?: IntNullableFilter<"Evento"> | number | null
    valorInscricao?: FloatNullableFilter<"Evento"> | number | null
    ativo?: BoolFilter<"Evento"> | boolean
    imagemUrl?: StringNullableFilter<"Evento"> | string | null
    createdAt?: DateTimeFilter<"Evento"> | Date | string
    updatedAt?: DateTimeFilter<"Evento"> | Date | string
    participacoes?: ParticipacaoEventoListRelationFilter
    comboios?: ComboioEventoListRelationFilter
  }

  export type EventoOrderByWithRelationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    dataEvento?: SortOrder
    localEvento?: SortOrder
    endereco?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    participantesMaximo?: SortOrderInput | SortOrder
    valorInscricao?: SortOrderInput | SortOrder
    ativo?: SortOrder
    imagemUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    participacoes?: ParticipacaoEventoOrderByRelationAggregateInput
    comboios?: ComboioEventoOrderByRelationAggregateInput
  }

  export type EventoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventoWhereInput | EventoWhereInput[]
    OR?: EventoWhereInput[]
    NOT?: EventoWhereInput | EventoWhereInput[]
    titulo?: StringFilter<"Evento"> | string
    descricao?: StringFilter<"Evento"> | string
    dataEvento?: DateTimeFilter<"Evento"> | Date | string
    localEvento?: StringFilter<"Evento"> | string
    endereco?: StringFilter<"Evento"> | string
    latitude?: FloatNullableFilter<"Evento"> | number | null
    longitude?: FloatNullableFilter<"Evento"> | number | null
    participantesMaximo?: IntNullableFilter<"Evento"> | number | null
    valorInscricao?: FloatNullableFilter<"Evento"> | number | null
    ativo?: BoolFilter<"Evento"> | boolean
    imagemUrl?: StringNullableFilter<"Evento"> | string | null
    createdAt?: DateTimeFilter<"Evento"> | Date | string
    updatedAt?: DateTimeFilter<"Evento"> | Date | string
    participacoes?: ParticipacaoEventoListRelationFilter
    comboios?: ComboioEventoListRelationFilter
  }, "id">

  export type EventoOrderByWithAggregationInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    dataEvento?: SortOrder
    localEvento?: SortOrder
    endereco?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    participantesMaximo?: SortOrderInput | SortOrder
    valorInscricao?: SortOrderInput | SortOrder
    ativo?: SortOrder
    imagemUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventoCountOrderByAggregateInput
    _avg?: EventoAvgOrderByAggregateInput
    _max?: EventoMaxOrderByAggregateInput
    _min?: EventoMinOrderByAggregateInput
    _sum?: EventoSumOrderByAggregateInput
  }

  export type EventoScalarWhereWithAggregatesInput = {
    AND?: EventoScalarWhereWithAggregatesInput | EventoScalarWhereWithAggregatesInput[]
    OR?: EventoScalarWhereWithAggregatesInput[]
    NOT?: EventoScalarWhereWithAggregatesInput | EventoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Evento"> | string
    titulo?: StringWithAggregatesFilter<"Evento"> | string
    descricao?: StringWithAggregatesFilter<"Evento"> | string
    dataEvento?: DateTimeWithAggregatesFilter<"Evento"> | Date | string
    localEvento?: StringWithAggregatesFilter<"Evento"> | string
    endereco?: StringWithAggregatesFilter<"Evento"> | string
    latitude?: FloatNullableWithAggregatesFilter<"Evento"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Evento"> | number | null
    participantesMaximo?: IntNullableWithAggregatesFilter<"Evento"> | number | null
    valorInscricao?: FloatNullableWithAggregatesFilter<"Evento"> | number | null
    ativo?: BoolWithAggregatesFilter<"Evento"> | boolean
    imagemUrl?: StringNullableWithAggregatesFilter<"Evento"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Evento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Evento"> | Date | string
  }

  export type ParticipacaoEventoWhereInput = {
    AND?: ParticipacaoEventoWhereInput | ParticipacaoEventoWhereInput[]
    OR?: ParticipacaoEventoWhereInput[]
    NOT?: ParticipacaoEventoWhereInput | ParticipacaoEventoWhereInput[]
    id?: StringFilter<"ParticipacaoEvento"> | string
    confirmado?: BoolFilter<"ParticipacaoEvento"> | boolean
    dataConfirmacao?: DateTimeNullableFilter<"ParticipacaoEvento"> | Date | string | null
    observacoes?: StringNullableFilter<"ParticipacaoEvento"> | string | null
    userId?: StringFilter<"ParticipacaoEvento"> | string
    eventoId?: StringFilter<"ParticipacaoEvento"> | string
    createdAt?: DateTimeFilter<"ParticipacaoEvento"> | Date | string
    updatedAt?: DateTimeFilter<"ParticipacaoEvento"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    evento?: XOR<EventoRelationFilter, EventoWhereInput>
  }

  export type ParticipacaoEventoOrderByWithRelationInput = {
    id?: SortOrder
    confirmado?: SortOrder
    dataConfirmacao?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    userId?: SortOrder
    eventoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    evento?: EventoOrderByWithRelationInput
  }

  export type ParticipacaoEventoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_eventoId?: ParticipacaoEventoUserIdEventoIdCompoundUniqueInput
    AND?: ParticipacaoEventoWhereInput | ParticipacaoEventoWhereInput[]
    OR?: ParticipacaoEventoWhereInput[]
    NOT?: ParticipacaoEventoWhereInput | ParticipacaoEventoWhereInput[]
    confirmado?: BoolFilter<"ParticipacaoEvento"> | boolean
    dataConfirmacao?: DateTimeNullableFilter<"ParticipacaoEvento"> | Date | string | null
    observacoes?: StringNullableFilter<"ParticipacaoEvento"> | string | null
    userId?: StringFilter<"ParticipacaoEvento"> | string
    eventoId?: StringFilter<"ParticipacaoEvento"> | string
    createdAt?: DateTimeFilter<"ParticipacaoEvento"> | Date | string
    updatedAt?: DateTimeFilter<"ParticipacaoEvento"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    evento?: XOR<EventoRelationFilter, EventoWhereInput>
  }, "id" | "userId_eventoId">

  export type ParticipacaoEventoOrderByWithAggregationInput = {
    id?: SortOrder
    confirmado?: SortOrder
    dataConfirmacao?: SortOrderInput | SortOrder
    observacoes?: SortOrderInput | SortOrder
    userId?: SortOrder
    eventoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ParticipacaoEventoCountOrderByAggregateInput
    _max?: ParticipacaoEventoMaxOrderByAggregateInput
    _min?: ParticipacaoEventoMinOrderByAggregateInput
  }

  export type ParticipacaoEventoScalarWhereWithAggregatesInput = {
    AND?: ParticipacaoEventoScalarWhereWithAggregatesInput | ParticipacaoEventoScalarWhereWithAggregatesInput[]
    OR?: ParticipacaoEventoScalarWhereWithAggregatesInput[]
    NOT?: ParticipacaoEventoScalarWhereWithAggregatesInput | ParticipacaoEventoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ParticipacaoEvento"> | string
    confirmado?: BoolWithAggregatesFilter<"ParticipacaoEvento"> | boolean
    dataConfirmacao?: DateTimeNullableWithAggregatesFilter<"ParticipacaoEvento"> | Date | string | null
    observacoes?: StringNullableWithAggregatesFilter<"ParticipacaoEvento"> | string | null
    userId?: StringWithAggregatesFilter<"ParticipacaoEvento"> | string
    eventoId?: StringWithAggregatesFilter<"ParticipacaoEvento"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ParticipacaoEvento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ParticipacaoEvento"> | Date | string
  }

  export type ComboioEventoWhereInput = {
    AND?: ComboioEventoWhereInput | ComboioEventoWhereInput[]
    OR?: ComboioEventoWhereInput[]
    NOT?: ComboioEventoWhereInput | ComboioEventoWhereInput[]
    id?: StringFilter<"ComboioEvento"> | string
    nome?: StringFilter<"ComboioEvento"> | string
    descricao?: StringNullableFilter<"ComboioEvento"> | string | null
    pontoEncontro?: StringFilter<"ComboioEvento"> | string
    horarioSaida?: DateTimeFilter<"ComboioEvento"> | Date | string
    vagas?: IntFilter<"ComboioEvento"> | number
    ativo?: BoolFilter<"ComboioEvento"> | boolean
    eventoId?: StringFilter<"ComboioEvento"> | string
    liderUserId?: StringFilter<"ComboioEvento"> | string
    createdAt?: DateTimeFilter<"ComboioEvento"> | Date | string
    updatedAt?: DateTimeFilter<"ComboioEvento"> | Date | string
    evento?: XOR<EventoRelationFilter, EventoWhereInput>
    lider?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ComboioEventoOrderByWithRelationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    pontoEncontro?: SortOrder
    horarioSaida?: SortOrder
    vagas?: SortOrder
    ativo?: SortOrder
    eventoId?: SortOrder
    liderUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    evento?: EventoOrderByWithRelationInput
    lider?: UserOrderByWithRelationInput
  }

  export type ComboioEventoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComboioEventoWhereInput | ComboioEventoWhereInput[]
    OR?: ComboioEventoWhereInput[]
    NOT?: ComboioEventoWhereInput | ComboioEventoWhereInput[]
    nome?: StringFilter<"ComboioEvento"> | string
    descricao?: StringNullableFilter<"ComboioEvento"> | string | null
    pontoEncontro?: StringFilter<"ComboioEvento"> | string
    horarioSaida?: DateTimeFilter<"ComboioEvento"> | Date | string
    vagas?: IntFilter<"ComboioEvento"> | number
    ativo?: BoolFilter<"ComboioEvento"> | boolean
    eventoId?: StringFilter<"ComboioEvento"> | string
    liderUserId?: StringFilter<"ComboioEvento"> | string
    createdAt?: DateTimeFilter<"ComboioEvento"> | Date | string
    updatedAt?: DateTimeFilter<"ComboioEvento"> | Date | string
    evento?: XOR<EventoRelationFilter, EventoWhereInput>
    lider?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ComboioEventoOrderByWithAggregationInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrderInput | SortOrder
    pontoEncontro?: SortOrder
    horarioSaida?: SortOrder
    vagas?: SortOrder
    ativo?: SortOrder
    eventoId?: SortOrder
    liderUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComboioEventoCountOrderByAggregateInput
    _avg?: ComboioEventoAvgOrderByAggregateInput
    _max?: ComboioEventoMaxOrderByAggregateInput
    _min?: ComboioEventoMinOrderByAggregateInput
    _sum?: ComboioEventoSumOrderByAggregateInput
  }

  export type ComboioEventoScalarWhereWithAggregatesInput = {
    AND?: ComboioEventoScalarWhereWithAggregatesInput | ComboioEventoScalarWhereWithAggregatesInput[]
    OR?: ComboioEventoScalarWhereWithAggregatesInput[]
    NOT?: ComboioEventoScalarWhereWithAggregatesInput | ComboioEventoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComboioEvento"> | string
    nome?: StringWithAggregatesFilter<"ComboioEvento"> | string
    descricao?: StringNullableWithAggregatesFilter<"ComboioEvento"> | string | null
    pontoEncontro?: StringWithAggregatesFilter<"ComboioEvento"> | string
    horarioSaida?: DateTimeWithAggregatesFilter<"ComboioEvento"> | Date | string
    vagas?: IntWithAggregatesFilter<"ComboioEvento"> | number
    ativo?: BoolWithAggregatesFilter<"ComboioEvento"> | boolean
    eventoId?: StringWithAggregatesFilter<"ComboioEvento"> | string
    liderUserId?: StringWithAggregatesFilter<"ComboioEvento"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ComboioEvento"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComboioEvento"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    familiares?: FamiliarCreateNestedManyWithoutUserInput
    premios?: PremioCreateNestedManyWithoutUserInput
    motos?: MotoCreateNestedManyWithoutUserInput
    participacoes?: ParticipacaoEventoCreateNestedManyWithoutUserInput
    comboiosLiderados?: ComboioEventoCreateNestedManyWithoutLiderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    familiares?: FamiliarUncheckedCreateNestedManyWithoutUserInput
    premios?: PremioUncheckedCreateNestedManyWithoutUserInput
    motos?: MotoUncheckedCreateNestedManyWithoutUserInput
    participacoes?: ParticipacaoEventoUncheckedCreateNestedManyWithoutUserInput
    comboiosLiderados?: ComboioEventoUncheckedCreateNestedManyWithoutLiderInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familiares?: FamiliarUpdateManyWithoutUserNestedInput
    premios?: PremioUpdateManyWithoutUserNestedInput
    motos?: MotoUpdateManyWithoutUserNestedInput
    participacoes?: ParticipacaoEventoUpdateManyWithoutUserNestedInput
    comboiosLiderados?: ComboioEventoUpdateManyWithoutLiderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familiares?: FamiliarUncheckedUpdateManyWithoutUserNestedInput
    premios?: PremioUncheckedUpdateManyWithoutUserNestedInput
    motos?: MotoUncheckedUpdateManyWithoutUserNestedInput
    participacoes?: ParticipacaoEventoUncheckedUpdateManyWithoutUserNestedInput
    comboiosLiderados?: ComboioEventoUncheckedUpdateManyWithoutLiderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamiliarCreateInput = {
    id?: string
    nome: string
    parentesco: string
    idade?: number | null
    telefone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutFamiliaresInput
  }

  export type FamiliarUncheckedCreateInput = {
    id?: string
    nome: string
    parentesco: string
    idade?: number | null
    telefone?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamiliarUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    parentesco?: StringFieldUpdateOperationsInput | string
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutFamiliaresNestedInput
  }

  export type FamiliarUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    parentesco?: StringFieldUpdateOperationsInput | string
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamiliarCreateManyInput = {
    id?: string
    nome: string
    parentesco: string
    idade?: number | null
    telefone?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamiliarUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    parentesco?: StringFieldUpdateOperationsInput | string
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamiliarUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    parentesco?: StringFieldUpdateOperationsInput | string
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PremioCreateInput = {
    id?: string
    titulo: string
    descricao?: string | null
    categoria: string
    ano: number
    posicao?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPremiosInput
  }

  export type PremioUncheckedCreateInput = {
    id?: string
    titulo: string
    descricao?: string | null
    categoria: string
    ano: number
    posicao?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PremioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    posicao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPremiosNestedInput
  }

  export type PremioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    posicao?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PremioCreateManyInput = {
    id?: string
    titulo: string
    descricao?: string | null
    categoria: string
    ano: number
    posicao?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PremioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    posicao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PremioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    posicao?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotoCreateInput = {
    id?: string
    marca: string
    modelo: string
    ano: number
    cor: string
    cilindrada: string
    placa?: string | null
    principal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMotosInput
  }

  export type MotoUncheckedCreateInput = {
    id?: string
    marca: string
    modelo: string
    ano: number
    cor: string
    cilindrada: string
    placa?: string | null
    principal?: boolean
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MotoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    cor?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMotosNestedInput
  }

  export type MotoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    cor?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    principal?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotoCreateManyInput = {
    id?: string
    marca: string
    modelo: string
    ano: number
    cor: string
    cilindrada: string
    placa?: string | null
    principal?: boolean
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MotoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    cor?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    cor?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    principal?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoCreateInput = {
    id?: string
    titulo: string
    descricao: string
    dataEvento: Date | string
    localEvento: string
    endereco: string
    latitude?: number | null
    longitude?: number | null
    participantesMaximo?: number | null
    valorInscricao?: number | null
    ativo?: boolean
    imagemUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participacoes?: ParticipacaoEventoCreateNestedManyWithoutEventoInput
    comboios?: ComboioEventoCreateNestedManyWithoutEventoInput
  }

  export type EventoUncheckedCreateInput = {
    id?: string
    titulo: string
    descricao: string
    dataEvento: Date | string
    localEvento: string
    endereco: string
    latitude?: number | null
    longitude?: number | null
    participantesMaximo?: number | null
    valorInscricao?: number | null
    ativo?: boolean
    imagemUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participacoes?: ParticipacaoEventoUncheckedCreateNestedManyWithoutEventoInput
    comboios?: ComboioEventoUncheckedCreateNestedManyWithoutEventoInput
  }

  export type EventoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataEvento?: DateTimeFieldUpdateOperationsInput | Date | string
    localEvento?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    participantesMaximo?: NullableIntFieldUpdateOperationsInput | number | null
    valorInscricao?: NullableFloatFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    imagemUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participacoes?: ParticipacaoEventoUpdateManyWithoutEventoNestedInput
    comboios?: ComboioEventoUpdateManyWithoutEventoNestedInput
  }

  export type EventoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataEvento?: DateTimeFieldUpdateOperationsInput | Date | string
    localEvento?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    participantesMaximo?: NullableIntFieldUpdateOperationsInput | number | null
    valorInscricao?: NullableFloatFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    imagemUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participacoes?: ParticipacaoEventoUncheckedUpdateManyWithoutEventoNestedInput
    comboios?: ComboioEventoUncheckedUpdateManyWithoutEventoNestedInput
  }

  export type EventoCreateManyInput = {
    id?: string
    titulo: string
    descricao: string
    dataEvento: Date | string
    localEvento: string
    endereco: string
    latitude?: number | null
    longitude?: number | null
    participantesMaximo?: number | null
    valorInscricao?: number | null
    ativo?: boolean
    imagemUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataEvento?: DateTimeFieldUpdateOperationsInput | Date | string
    localEvento?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    participantesMaximo?: NullableIntFieldUpdateOperationsInput | number | null
    valorInscricao?: NullableFloatFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    imagemUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataEvento?: DateTimeFieldUpdateOperationsInput | Date | string
    localEvento?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    participantesMaximo?: NullableIntFieldUpdateOperationsInput | number | null
    valorInscricao?: NullableFloatFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    imagemUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipacaoEventoCreateInput = {
    id?: string
    confirmado?: boolean
    dataConfirmacao?: Date | string | null
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParticipacoesInput
    evento: EventoCreateNestedOneWithoutParticipacoesInput
  }

  export type ParticipacaoEventoUncheckedCreateInput = {
    id?: string
    confirmado?: boolean
    dataConfirmacao?: Date | string | null
    observacoes?: string | null
    userId: string
    eventoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipacaoEventoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    dataConfirmacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParticipacoesNestedInput
    evento?: EventoUpdateOneRequiredWithoutParticipacoesNestedInput
  }

  export type ParticipacaoEventoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    dataConfirmacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    eventoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipacaoEventoCreateManyInput = {
    id?: string
    confirmado?: boolean
    dataConfirmacao?: Date | string | null
    observacoes?: string | null
    userId: string
    eventoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipacaoEventoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    dataConfirmacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipacaoEventoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    dataConfirmacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    eventoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComboioEventoCreateInput = {
    id?: string
    nome: string
    descricao?: string | null
    pontoEncontro: string
    horarioSaida: Date | string
    vagas?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evento: EventoCreateNestedOneWithoutComboiosInput
    lider: UserCreateNestedOneWithoutComboiosLideradosInput
  }

  export type ComboioEventoUncheckedCreateInput = {
    id?: string
    nome: string
    descricao?: string | null
    pontoEncontro: string
    horarioSaida: Date | string
    vagas?: number
    ativo?: boolean
    eventoId: string
    liderUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComboioEventoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    pontoEncontro?: StringFieldUpdateOperationsInput | string
    horarioSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    vagas?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evento?: EventoUpdateOneRequiredWithoutComboiosNestedInput
    lider?: UserUpdateOneRequiredWithoutComboiosLideradosNestedInput
  }

  export type ComboioEventoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    pontoEncontro?: StringFieldUpdateOperationsInput | string
    horarioSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    vagas?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    eventoId?: StringFieldUpdateOperationsInput | string
    liderUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComboioEventoCreateManyInput = {
    id?: string
    nome: string
    descricao?: string | null
    pontoEncontro: string
    horarioSaida: Date | string
    vagas?: number
    ativo?: boolean
    eventoId: string
    liderUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComboioEventoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    pontoEncontro?: StringFieldUpdateOperationsInput | string
    horarioSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    vagas?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComboioEventoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    pontoEncontro?: StringFieldUpdateOperationsInput | string
    horarioSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    vagas?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    eventoId?: StringFieldUpdateOperationsInput | string
    liderUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FamiliarListRelationFilter = {
    every?: FamiliarWhereInput
    some?: FamiliarWhereInput
    none?: FamiliarWhereInput
  }

  export type PremioListRelationFilter = {
    every?: PremioWhereInput
    some?: PremioWhereInput
    none?: PremioWhereInput
  }

  export type MotoListRelationFilter = {
    every?: MotoWhereInput
    some?: MotoWhereInput
    none?: MotoWhereInput
  }

  export type ParticipacaoEventoListRelationFilter = {
    every?: ParticipacaoEventoWhereInput
    some?: ParticipacaoEventoWhereInput
    none?: ParticipacaoEventoWhereInput
  }

  export type ComboioEventoListRelationFilter = {
    every?: ComboioEventoWhereInput
    some?: ComboioEventoWhereInput
    none?: ComboioEventoWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FamiliarOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PremioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MotoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParticipacaoEventoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComboioEventoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nomeCompleto?: SortOrder
    telefone?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    dataNascimento?: SortOrder
    tipoUsuario?: SortOrder
    ativo?: SortOrder
    emailVerificado?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nomeCompleto?: SortOrder
    telefone?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    dataNascimento?: SortOrder
    tipoUsuario?: SortOrder
    ativo?: SortOrder
    emailVerificado?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    nomeCompleto?: SortOrder
    telefone?: SortOrder
    cidade?: SortOrder
    estado?: SortOrder
    dataNascimento?: SortOrder
    tipoUsuario?: SortOrder
    ativo?: SortOrder
    emailVerificado?: SortOrder
    avatarUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FamiliarCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    parentesco?: SortOrder
    idade?: SortOrder
    telefone?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamiliarAvgOrderByAggregateInput = {
    idade?: SortOrder
  }

  export type FamiliarMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    parentesco?: SortOrder
    idade?: SortOrder
    telefone?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamiliarMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    parentesco?: SortOrder
    idade?: SortOrder
    telefone?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FamiliarSumOrderByAggregateInput = {
    idade?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PremioCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    categoria?: SortOrder
    ano?: SortOrder
    posicao?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PremioAvgOrderByAggregateInput = {
    ano?: SortOrder
  }

  export type PremioMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    categoria?: SortOrder
    ano?: SortOrder
    posicao?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PremioMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    categoria?: SortOrder
    ano?: SortOrder
    posicao?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PremioSumOrderByAggregateInput = {
    ano?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type MotoCountOrderByAggregateInput = {
    id?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    ano?: SortOrder
    cor?: SortOrder
    cilindrada?: SortOrder
    placa?: SortOrder
    principal?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotoAvgOrderByAggregateInput = {
    ano?: SortOrder
  }

  export type MotoMaxOrderByAggregateInput = {
    id?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    ano?: SortOrder
    cor?: SortOrder
    cilindrada?: SortOrder
    placa?: SortOrder
    principal?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotoMinOrderByAggregateInput = {
    id?: SortOrder
    marca?: SortOrder
    modelo?: SortOrder
    ano?: SortOrder
    cor?: SortOrder
    cilindrada?: SortOrder
    placa?: SortOrder
    principal?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MotoSumOrderByAggregateInput = {
    ano?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type EventoCountOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    dataEvento?: SortOrder
    localEvento?: SortOrder
    endereco?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    participantesMaximo?: SortOrder
    valorInscricao?: SortOrder
    ativo?: SortOrder
    imagemUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventoAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    participantesMaximo?: SortOrder
    valorInscricao?: SortOrder
  }

  export type EventoMaxOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    dataEvento?: SortOrder
    localEvento?: SortOrder
    endereco?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    participantesMaximo?: SortOrder
    valorInscricao?: SortOrder
    ativo?: SortOrder
    imagemUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventoMinOrderByAggregateInput = {
    id?: SortOrder
    titulo?: SortOrder
    descricao?: SortOrder
    dataEvento?: SortOrder
    localEvento?: SortOrder
    endereco?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    participantesMaximo?: SortOrder
    valorInscricao?: SortOrder
    ativo?: SortOrder
    imagemUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventoSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    participantesMaximo?: SortOrder
    valorInscricao?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EventoRelationFilter = {
    is?: EventoWhereInput
    isNot?: EventoWhereInput
  }

  export type ParticipacaoEventoUserIdEventoIdCompoundUniqueInput = {
    userId: string
    eventoId: string
  }

  export type ParticipacaoEventoCountOrderByAggregateInput = {
    id?: SortOrder
    confirmado?: SortOrder
    dataConfirmacao?: SortOrder
    observacoes?: SortOrder
    userId?: SortOrder
    eventoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParticipacaoEventoMaxOrderByAggregateInput = {
    id?: SortOrder
    confirmado?: SortOrder
    dataConfirmacao?: SortOrder
    observacoes?: SortOrder
    userId?: SortOrder
    eventoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ParticipacaoEventoMinOrderByAggregateInput = {
    id?: SortOrder
    confirmado?: SortOrder
    dataConfirmacao?: SortOrder
    observacoes?: SortOrder
    userId?: SortOrder
    eventoId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComboioEventoCountOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    pontoEncontro?: SortOrder
    horarioSaida?: SortOrder
    vagas?: SortOrder
    ativo?: SortOrder
    eventoId?: SortOrder
    liderUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComboioEventoAvgOrderByAggregateInput = {
    vagas?: SortOrder
  }

  export type ComboioEventoMaxOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    pontoEncontro?: SortOrder
    horarioSaida?: SortOrder
    vagas?: SortOrder
    ativo?: SortOrder
    eventoId?: SortOrder
    liderUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComboioEventoMinOrderByAggregateInput = {
    id?: SortOrder
    nome?: SortOrder
    descricao?: SortOrder
    pontoEncontro?: SortOrder
    horarioSaida?: SortOrder
    vagas?: SortOrder
    ativo?: SortOrder
    eventoId?: SortOrder
    liderUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComboioEventoSumOrderByAggregateInput = {
    vagas?: SortOrder
  }

  export type FamiliarCreateNestedManyWithoutUserInput = {
    create?: XOR<FamiliarCreateWithoutUserInput, FamiliarUncheckedCreateWithoutUserInput> | FamiliarCreateWithoutUserInput[] | FamiliarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamiliarCreateOrConnectWithoutUserInput | FamiliarCreateOrConnectWithoutUserInput[]
    createMany?: FamiliarCreateManyUserInputEnvelope
    connect?: FamiliarWhereUniqueInput | FamiliarWhereUniqueInput[]
  }

  export type PremioCreateNestedManyWithoutUserInput = {
    create?: XOR<PremioCreateWithoutUserInput, PremioUncheckedCreateWithoutUserInput> | PremioCreateWithoutUserInput[] | PremioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PremioCreateOrConnectWithoutUserInput | PremioCreateOrConnectWithoutUserInput[]
    createMany?: PremioCreateManyUserInputEnvelope
    connect?: PremioWhereUniqueInput | PremioWhereUniqueInput[]
  }

  export type MotoCreateNestedManyWithoutUserInput = {
    create?: XOR<MotoCreateWithoutUserInput, MotoUncheckedCreateWithoutUserInput> | MotoCreateWithoutUserInput[] | MotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MotoCreateOrConnectWithoutUserInput | MotoCreateOrConnectWithoutUserInput[]
    createMany?: MotoCreateManyUserInputEnvelope
    connect?: MotoWhereUniqueInput | MotoWhereUniqueInput[]
  }

  export type ParticipacaoEventoCreateNestedManyWithoutUserInput = {
    create?: XOR<ParticipacaoEventoCreateWithoutUserInput, ParticipacaoEventoUncheckedCreateWithoutUserInput> | ParticipacaoEventoCreateWithoutUserInput[] | ParticipacaoEventoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParticipacaoEventoCreateOrConnectWithoutUserInput | ParticipacaoEventoCreateOrConnectWithoutUserInput[]
    createMany?: ParticipacaoEventoCreateManyUserInputEnvelope
    connect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
  }

  export type ComboioEventoCreateNestedManyWithoutLiderInput = {
    create?: XOR<ComboioEventoCreateWithoutLiderInput, ComboioEventoUncheckedCreateWithoutLiderInput> | ComboioEventoCreateWithoutLiderInput[] | ComboioEventoUncheckedCreateWithoutLiderInput[]
    connectOrCreate?: ComboioEventoCreateOrConnectWithoutLiderInput | ComboioEventoCreateOrConnectWithoutLiderInput[]
    createMany?: ComboioEventoCreateManyLiderInputEnvelope
    connect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
  }

  export type FamiliarUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<FamiliarCreateWithoutUserInput, FamiliarUncheckedCreateWithoutUserInput> | FamiliarCreateWithoutUserInput[] | FamiliarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamiliarCreateOrConnectWithoutUserInput | FamiliarCreateOrConnectWithoutUserInput[]
    createMany?: FamiliarCreateManyUserInputEnvelope
    connect?: FamiliarWhereUniqueInput | FamiliarWhereUniqueInput[]
  }

  export type PremioUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PremioCreateWithoutUserInput, PremioUncheckedCreateWithoutUserInput> | PremioCreateWithoutUserInput[] | PremioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PremioCreateOrConnectWithoutUserInput | PremioCreateOrConnectWithoutUserInput[]
    createMany?: PremioCreateManyUserInputEnvelope
    connect?: PremioWhereUniqueInput | PremioWhereUniqueInput[]
  }

  export type MotoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MotoCreateWithoutUserInput, MotoUncheckedCreateWithoutUserInput> | MotoCreateWithoutUserInput[] | MotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MotoCreateOrConnectWithoutUserInput | MotoCreateOrConnectWithoutUserInput[]
    createMany?: MotoCreateManyUserInputEnvelope
    connect?: MotoWhereUniqueInput | MotoWhereUniqueInput[]
  }

  export type ParticipacaoEventoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ParticipacaoEventoCreateWithoutUserInput, ParticipacaoEventoUncheckedCreateWithoutUserInput> | ParticipacaoEventoCreateWithoutUserInput[] | ParticipacaoEventoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParticipacaoEventoCreateOrConnectWithoutUserInput | ParticipacaoEventoCreateOrConnectWithoutUserInput[]
    createMany?: ParticipacaoEventoCreateManyUserInputEnvelope
    connect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
  }

  export type ComboioEventoUncheckedCreateNestedManyWithoutLiderInput = {
    create?: XOR<ComboioEventoCreateWithoutLiderInput, ComboioEventoUncheckedCreateWithoutLiderInput> | ComboioEventoCreateWithoutLiderInput[] | ComboioEventoUncheckedCreateWithoutLiderInput[]
    connectOrCreate?: ComboioEventoCreateOrConnectWithoutLiderInput | ComboioEventoCreateOrConnectWithoutLiderInput[]
    createMany?: ComboioEventoCreateManyLiderInputEnvelope
    connect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FamiliarUpdateManyWithoutUserNestedInput = {
    create?: XOR<FamiliarCreateWithoutUserInput, FamiliarUncheckedCreateWithoutUserInput> | FamiliarCreateWithoutUserInput[] | FamiliarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamiliarCreateOrConnectWithoutUserInput | FamiliarCreateOrConnectWithoutUserInput[]
    upsert?: FamiliarUpsertWithWhereUniqueWithoutUserInput | FamiliarUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FamiliarCreateManyUserInputEnvelope
    set?: FamiliarWhereUniqueInput | FamiliarWhereUniqueInput[]
    disconnect?: FamiliarWhereUniqueInput | FamiliarWhereUniqueInput[]
    delete?: FamiliarWhereUniqueInput | FamiliarWhereUniqueInput[]
    connect?: FamiliarWhereUniqueInput | FamiliarWhereUniqueInput[]
    update?: FamiliarUpdateWithWhereUniqueWithoutUserInput | FamiliarUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FamiliarUpdateManyWithWhereWithoutUserInput | FamiliarUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FamiliarScalarWhereInput | FamiliarScalarWhereInput[]
  }

  export type PremioUpdateManyWithoutUserNestedInput = {
    create?: XOR<PremioCreateWithoutUserInput, PremioUncheckedCreateWithoutUserInput> | PremioCreateWithoutUserInput[] | PremioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PremioCreateOrConnectWithoutUserInput | PremioCreateOrConnectWithoutUserInput[]
    upsert?: PremioUpsertWithWhereUniqueWithoutUserInput | PremioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PremioCreateManyUserInputEnvelope
    set?: PremioWhereUniqueInput | PremioWhereUniqueInput[]
    disconnect?: PremioWhereUniqueInput | PremioWhereUniqueInput[]
    delete?: PremioWhereUniqueInput | PremioWhereUniqueInput[]
    connect?: PremioWhereUniqueInput | PremioWhereUniqueInput[]
    update?: PremioUpdateWithWhereUniqueWithoutUserInput | PremioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PremioUpdateManyWithWhereWithoutUserInput | PremioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PremioScalarWhereInput | PremioScalarWhereInput[]
  }

  export type MotoUpdateManyWithoutUserNestedInput = {
    create?: XOR<MotoCreateWithoutUserInput, MotoUncheckedCreateWithoutUserInput> | MotoCreateWithoutUserInput[] | MotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MotoCreateOrConnectWithoutUserInput | MotoCreateOrConnectWithoutUserInput[]
    upsert?: MotoUpsertWithWhereUniqueWithoutUserInput | MotoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MotoCreateManyUserInputEnvelope
    set?: MotoWhereUniqueInput | MotoWhereUniqueInput[]
    disconnect?: MotoWhereUniqueInput | MotoWhereUniqueInput[]
    delete?: MotoWhereUniqueInput | MotoWhereUniqueInput[]
    connect?: MotoWhereUniqueInput | MotoWhereUniqueInput[]
    update?: MotoUpdateWithWhereUniqueWithoutUserInput | MotoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MotoUpdateManyWithWhereWithoutUserInput | MotoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MotoScalarWhereInput | MotoScalarWhereInput[]
  }

  export type ParticipacaoEventoUpdateManyWithoutUserNestedInput = {
    create?: XOR<ParticipacaoEventoCreateWithoutUserInput, ParticipacaoEventoUncheckedCreateWithoutUserInput> | ParticipacaoEventoCreateWithoutUserInput[] | ParticipacaoEventoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParticipacaoEventoCreateOrConnectWithoutUserInput | ParticipacaoEventoCreateOrConnectWithoutUserInput[]
    upsert?: ParticipacaoEventoUpsertWithWhereUniqueWithoutUserInput | ParticipacaoEventoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ParticipacaoEventoCreateManyUserInputEnvelope
    set?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    disconnect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    delete?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    connect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    update?: ParticipacaoEventoUpdateWithWhereUniqueWithoutUserInput | ParticipacaoEventoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ParticipacaoEventoUpdateManyWithWhereWithoutUserInput | ParticipacaoEventoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ParticipacaoEventoScalarWhereInput | ParticipacaoEventoScalarWhereInput[]
  }

  export type ComboioEventoUpdateManyWithoutLiderNestedInput = {
    create?: XOR<ComboioEventoCreateWithoutLiderInput, ComboioEventoUncheckedCreateWithoutLiderInput> | ComboioEventoCreateWithoutLiderInput[] | ComboioEventoUncheckedCreateWithoutLiderInput[]
    connectOrCreate?: ComboioEventoCreateOrConnectWithoutLiderInput | ComboioEventoCreateOrConnectWithoutLiderInput[]
    upsert?: ComboioEventoUpsertWithWhereUniqueWithoutLiderInput | ComboioEventoUpsertWithWhereUniqueWithoutLiderInput[]
    createMany?: ComboioEventoCreateManyLiderInputEnvelope
    set?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    disconnect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    delete?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    connect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    update?: ComboioEventoUpdateWithWhereUniqueWithoutLiderInput | ComboioEventoUpdateWithWhereUniqueWithoutLiderInput[]
    updateMany?: ComboioEventoUpdateManyWithWhereWithoutLiderInput | ComboioEventoUpdateManyWithWhereWithoutLiderInput[]
    deleteMany?: ComboioEventoScalarWhereInput | ComboioEventoScalarWhereInput[]
  }

  export type FamiliarUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<FamiliarCreateWithoutUserInput, FamiliarUncheckedCreateWithoutUserInput> | FamiliarCreateWithoutUserInput[] | FamiliarUncheckedCreateWithoutUserInput[]
    connectOrCreate?: FamiliarCreateOrConnectWithoutUserInput | FamiliarCreateOrConnectWithoutUserInput[]
    upsert?: FamiliarUpsertWithWhereUniqueWithoutUserInput | FamiliarUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: FamiliarCreateManyUserInputEnvelope
    set?: FamiliarWhereUniqueInput | FamiliarWhereUniqueInput[]
    disconnect?: FamiliarWhereUniqueInput | FamiliarWhereUniqueInput[]
    delete?: FamiliarWhereUniqueInput | FamiliarWhereUniqueInput[]
    connect?: FamiliarWhereUniqueInput | FamiliarWhereUniqueInput[]
    update?: FamiliarUpdateWithWhereUniqueWithoutUserInput | FamiliarUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: FamiliarUpdateManyWithWhereWithoutUserInput | FamiliarUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: FamiliarScalarWhereInput | FamiliarScalarWhereInput[]
  }

  export type PremioUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PremioCreateWithoutUserInput, PremioUncheckedCreateWithoutUserInput> | PremioCreateWithoutUserInput[] | PremioUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PremioCreateOrConnectWithoutUserInput | PremioCreateOrConnectWithoutUserInput[]
    upsert?: PremioUpsertWithWhereUniqueWithoutUserInput | PremioUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PremioCreateManyUserInputEnvelope
    set?: PremioWhereUniqueInput | PremioWhereUniqueInput[]
    disconnect?: PremioWhereUniqueInput | PremioWhereUniqueInput[]
    delete?: PremioWhereUniqueInput | PremioWhereUniqueInput[]
    connect?: PremioWhereUniqueInput | PremioWhereUniqueInput[]
    update?: PremioUpdateWithWhereUniqueWithoutUserInput | PremioUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PremioUpdateManyWithWhereWithoutUserInput | PremioUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PremioScalarWhereInput | PremioScalarWhereInput[]
  }

  export type MotoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MotoCreateWithoutUserInput, MotoUncheckedCreateWithoutUserInput> | MotoCreateWithoutUserInput[] | MotoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MotoCreateOrConnectWithoutUserInput | MotoCreateOrConnectWithoutUserInput[]
    upsert?: MotoUpsertWithWhereUniqueWithoutUserInput | MotoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MotoCreateManyUserInputEnvelope
    set?: MotoWhereUniqueInput | MotoWhereUniqueInput[]
    disconnect?: MotoWhereUniqueInput | MotoWhereUniqueInput[]
    delete?: MotoWhereUniqueInput | MotoWhereUniqueInput[]
    connect?: MotoWhereUniqueInput | MotoWhereUniqueInput[]
    update?: MotoUpdateWithWhereUniqueWithoutUserInput | MotoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MotoUpdateManyWithWhereWithoutUserInput | MotoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MotoScalarWhereInput | MotoScalarWhereInput[]
  }

  export type ParticipacaoEventoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ParticipacaoEventoCreateWithoutUserInput, ParticipacaoEventoUncheckedCreateWithoutUserInput> | ParticipacaoEventoCreateWithoutUserInput[] | ParticipacaoEventoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ParticipacaoEventoCreateOrConnectWithoutUserInput | ParticipacaoEventoCreateOrConnectWithoutUserInput[]
    upsert?: ParticipacaoEventoUpsertWithWhereUniqueWithoutUserInput | ParticipacaoEventoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ParticipacaoEventoCreateManyUserInputEnvelope
    set?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    disconnect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    delete?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    connect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    update?: ParticipacaoEventoUpdateWithWhereUniqueWithoutUserInput | ParticipacaoEventoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ParticipacaoEventoUpdateManyWithWhereWithoutUserInput | ParticipacaoEventoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ParticipacaoEventoScalarWhereInput | ParticipacaoEventoScalarWhereInput[]
  }

  export type ComboioEventoUncheckedUpdateManyWithoutLiderNestedInput = {
    create?: XOR<ComboioEventoCreateWithoutLiderInput, ComboioEventoUncheckedCreateWithoutLiderInput> | ComboioEventoCreateWithoutLiderInput[] | ComboioEventoUncheckedCreateWithoutLiderInput[]
    connectOrCreate?: ComboioEventoCreateOrConnectWithoutLiderInput | ComboioEventoCreateOrConnectWithoutLiderInput[]
    upsert?: ComboioEventoUpsertWithWhereUniqueWithoutLiderInput | ComboioEventoUpsertWithWhereUniqueWithoutLiderInput[]
    createMany?: ComboioEventoCreateManyLiderInputEnvelope
    set?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    disconnect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    delete?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    connect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    update?: ComboioEventoUpdateWithWhereUniqueWithoutLiderInput | ComboioEventoUpdateWithWhereUniqueWithoutLiderInput[]
    updateMany?: ComboioEventoUpdateManyWithWhereWithoutLiderInput | ComboioEventoUpdateManyWithWhereWithoutLiderInput[]
    deleteMany?: ComboioEventoScalarWhereInput | ComboioEventoScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutFamiliaresInput = {
    create?: XOR<UserCreateWithoutFamiliaresInput, UserUncheckedCreateWithoutFamiliaresInput>
    connectOrCreate?: UserCreateOrConnectWithoutFamiliaresInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutFamiliaresNestedInput = {
    create?: XOR<UserCreateWithoutFamiliaresInput, UserUncheckedCreateWithoutFamiliaresInput>
    connectOrCreate?: UserCreateOrConnectWithoutFamiliaresInput
    upsert?: UserUpsertWithoutFamiliaresInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFamiliaresInput, UserUpdateWithoutFamiliaresInput>, UserUncheckedUpdateWithoutFamiliaresInput>
  }

  export type UserCreateNestedOneWithoutPremiosInput = {
    create?: XOR<UserCreateWithoutPremiosInput, UserUncheckedCreateWithoutPremiosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPremiosInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPremiosNestedInput = {
    create?: XOR<UserCreateWithoutPremiosInput, UserUncheckedCreateWithoutPremiosInput>
    connectOrCreate?: UserCreateOrConnectWithoutPremiosInput
    upsert?: UserUpsertWithoutPremiosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPremiosInput, UserUpdateWithoutPremiosInput>, UserUncheckedUpdateWithoutPremiosInput>
  }

  export type UserCreateNestedOneWithoutMotosInput = {
    create?: XOR<UserCreateWithoutMotosInput, UserUncheckedCreateWithoutMotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutMotosInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMotosNestedInput = {
    create?: XOR<UserCreateWithoutMotosInput, UserUncheckedCreateWithoutMotosInput>
    connectOrCreate?: UserCreateOrConnectWithoutMotosInput
    upsert?: UserUpsertWithoutMotosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMotosInput, UserUpdateWithoutMotosInput>, UserUncheckedUpdateWithoutMotosInput>
  }

  export type ParticipacaoEventoCreateNestedManyWithoutEventoInput = {
    create?: XOR<ParticipacaoEventoCreateWithoutEventoInput, ParticipacaoEventoUncheckedCreateWithoutEventoInput> | ParticipacaoEventoCreateWithoutEventoInput[] | ParticipacaoEventoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: ParticipacaoEventoCreateOrConnectWithoutEventoInput | ParticipacaoEventoCreateOrConnectWithoutEventoInput[]
    createMany?: ParticipacaoEventoCreateManyEventoInputEnvelope
    connect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
  }

  export type ComboioEventoCreateNestedManyWithoutEventoInput = {
    create?: XOR<ComboioEventoCreateWithoutEventoInput, ComboioEventoUncheckedCreateWithoutEventoInput> | ComboioEventoCreateWithoutEventoInput[] | ComboioEventoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: ComboioEventoCreateOrConnectWithoutEventoInput | ComboioEventoCreateOrConnectWithoutEventoInput[]
    createMany?: ComboioEventoCreateManyEventoInputEnvelope
    connect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
  }

  export type ParticipacaoEventoUncheckedCreateNestedManyWithoutEventoInput = {
    create?: XOR<ParticipacaoEventoCreateWithoutEventoInput, ParticipacaoEventoUncheckedCreateWithoutEventoInput> | ParticipacaoEventoCreateWithoutEventoInput[] | ParticipacaoEventoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: ParticipacaoEventoCreateOrConnectWithoutEventoInput | ParticipacaoEventoCreateOrConnectWithoutEventoInput[]
    createMany?: ParticipacaoEventoCreateManyEventoInputEnvelope
    connect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
  }

  export type ComboioEventoUncheckedCreateNestedManyWithoutEventoInput = {
    create?: XOR<ComboioEventoCreateWithoutEventoInput, ComboioEventoUncheckedCreateWithoutEventoInput> | ComboioEventoCreateWithoutEventoInput[] | ComboioEventoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: ComboioEventoCreateOrConnectWithoutEventoInput | ComboioEventoCreateOrConnectWithoutEventoInput[]
    createMany?: ComboioEventoCreateManyEventoInputEnvelope
    connect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ParticipacaoEventoUpdateManyWithoutEventoNestedInput = {
    create?: XOR<ParticipacaoEventoCreateWithoutEventoInput, ParticipacaoEventoUncheckedCreateWithoutEventoInput> | ParticipacaoEventoCreateWithoutEventoInput[] | ParticipacaoEventoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: ParticipacaoEventoCreateOrConnectWithoutEventoInput | ParticipacaoEventoCreateOrConnectWithoutEventoInput[]
    upsert?: ParticipacaoEventoUpsertWithWhereUniqueWithoutEventoInput | ParticipacaoEventoUpsertWithWhereUniqueWithoutEventoInput[]
    createMany?: ParticipacaoEventoCreateManyEventoInputEnvelope
    set?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    disconnect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    delete?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    connect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    update?: ParticipacaoEventoUpdateWithWhereUniqueWithoutEventoInput | ParticipacaoEventoUpdateWithWhereUniqueWithoutEventoInput[]
    updateMany?: ParticipacaoEventoUpdateManyWithWhereWithoutEventoInput | ParticipacaoEventoUpdateManyWithWhereWithoutEventoInput[]
    deleteMany?: ParticipacaoEventoScalarWhereInput | ParticipacaoEventoScalarWhereInput[]
  }

  export type ComboioEventoUpdateManyWithoutEventoNestedInput = {
    create?: XOR<ComboioEventoCreateWithoutEventoInput, ComboioEventoUncheckedCreateWithoutEventoInput> | ComboioEventoCreateWithoutEventoInput[] | ComboioEventoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: ComboioEventoCreateOrConnectWithoutEventoInput | ComboioEventoCreateOrConnectWithoutEventoInput[]
    upsert?: ComboioEventoUpsertWithWhereUniqueWithoutEventoInput | ComboioEventoUpsertWithWhereUniqueWithoutEventoInput[]
    createMany?: ComboioEventoCreateManyEventoInputEnvelope
    set?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    disconnect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    delete?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    connect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    update?: ComboioEventoUpdateWithWhereUniqueWithoutEventoInput | ComboioEventoUpdateWithWhereUniqueWithoutEventoInput[]
    updateMany?: ComboioEventoUpdateManyWithWhereWithoutEventoInput | ComboioEventoUpdateManyWithWhereWithoutEventoInput[]
    deleteMany?: ComboioEventoScalarWhereInput | ComboioEventoScalarWhereInput[]
  }

  export type ParticipacaoEventoUncheckedUpdateManyWithoutEventoNestedInput = {
    create?: XOR<ParticipacaoEventoCreateWithoutEventoInput, ParticipacaoEventoUncheckedCreateWithoutEventoInput> | ParticipacaoEventoCreateWithoutEventoInput[] | ParticipacaoEventoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: ParticipacaoEventoCreateOrConnectWithoutEventoInput | ParticipacaoEventoCreateOrConnectWithoutEventoInput[]
    upsert?: ParticipacaoEventoUpsertWithWhereUniqueWithoutEventoInput | ParticipacaoEventoUpsertWithWhereUniqueWithoutEventoInput[]
    createMany?: ParticipacaoEventoCreateManyEventoInputEnvelope
    set?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    disconnect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    delete?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    connect?: ParticipacaoEventoWhereUniqueInput | ParticipacaoEventoWhereUniqueInput[]
    update?: ParticipacaoEventoUpdateWithWhereUniqueWithoutEventoInput | ParticipacaoEventoUpdateWithWhereUniqueWithoutEventoInput[]
    updateMany?: ParticipacaoEventoUpdateManyWithWhereWithoutEventoInput | ParticipacaoEventoUpdateManyWithWhereWithoutEventoInput[]
    deleteMany?: ParticipacaoEventoScalarWhereInput | ParticipacaoEventoScalarWhereInput[]
  }

  export type ComboioEventoUncheckedUpdateManyWithoutEventoNestedInput = {
    create?: XOR<ComboioEventoCreateWithoutEventoInput, ComboioEventoUncheckedCreateWithoutEventoInput> | ComboioEventoCreateWithoutEventoInput[] | ComboioEventoUncheckedCreateWithoutEventoInput[]
    connectOrCreate?: ComboioEventoCreateOrConnectWithoutEventoInput | ComboioEventoCreateOrConnectWithoutEventoInput[]
    upsert?: ComboioEventoUpsertWithWhereUniqueWithoutEventoInput | ComboioEventoUpsertWithWhereUniqueWithoutEventoInput[]
    createMany?: ComboioEventoCreateManyEventoInputEnvelope
    set?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    disconnect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    delete?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    connect?: ComboioEventoWhereUniqueInput | ComboioEventoWhereUniqueInput[]
    update?: ComboioEventoUpdateWithWhereUniqueWithoutEventoInput | ComboioEventoUpdateWithWhereUniqueWithoutEventoInput[]
    updateMany?: ComboioEventoUpdateManyWithWhereWithoutEventoInput | ComboioEventoUpdateManyWithWhereWithoutEventoInput[]
    deleteMany?: ComboioEventoScalarWhereInput | ComboioEventoScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutParticipacoesInput = {
    create?: XOR<UserCreateWithoutParticipacoesInput, UserUncheckedCreateWithoutParticipacoesInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipacoesInput
    connect?: UserWhereUniqueInput
  }

  export type EventoCreateNestedOneWithoutParticipacoesInput = {
    create?: XOR<EventoCreateWithoutParticipacoesInput, EventoUncheckedCreateWithoutParticipacoesInput>
    connectOrCreate?: EventoCreateOrConnectWithoutParticipacoesInput
    connect?: EventoWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutParticipacoesNestedInput = {
    create?: XOR<UserCreateWithoutParticipacoesInput, UserUncheckedCreateWithoutParticipacoesInput>
    connectOrCreate?: UserCreateOrConnectWithoutParticipacoesInput
    upsert?: UserUpsertWithoutParticipacoesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutParticipacoesInput, UserUpdateWithoutParticipacoesInput>, UserUncheckedUpdateWithoutParticipacoesInput>
  }

  export type EventoUpdateOneRequiredWithoutParticipacoesNestedInput = {
    create?: XOR<EventoCreateWithoutParticipacoesInput, EventoUncheckedCreateWithoutParticipacoesInput>
    connectOrCreate?: EventoCreateOrConnectWithoutParticipacoesInput
    upsert?: EventoUpsertWithoutParticipacoesInput
    connect?: EventoWhereUniqueInput
    update?: XOR<XOR<EventoUpdateToOneWithWhereWithoutParticipacoesInput, EventoUpdateWithoutParticipacoesInput>, EventoUncheckedUpdateWithoutParticipacoesInput>
  }

  export type EventoCreateNestedOneWithoutComboiosInput = {
    create?: XOR<EventoCreateWithoutComboiosInput, EventoUncheckedCreateWithoutComboiosInput>
    connectOrCreate?: EventoCreateOrConnectWithoutComboiosInput
    connect?: EventoWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutComboiosLideradosInput = {
    create?: XOR<UserCreateWithoutComboiosLideradosInput, UserUncheckedCreateWithoutComboiosLideradosInput>
    connectOrCreate?: UserCreateOrConnectWithoutComboiosLideradosInput
    connect?: UserWhereUniqueInput
  }

  export type EventoUpdateOneRequiredWithoutComboiosNestedInput = {
    create?: XOR<EventoCreateWithoutComboiosInput, EventoUncheckedCreateWithoutComboiosInput>
    connectOrCreate?: EventoCreateOrConnectWithoutComboiosInput
    upsert?: EventoUpsertWithoutComboiosInput
    connect?: EventoWhereUniqueInput
    update?: XOR<XOR<EventoUpdateToOneWithWhereWithoutComboiosInput, EventoUpdateWithoutComboiosInput>, EventoUncheckedUpdateWithoutComboiosInput>
  }

  export type UserUpdateOneRequiredWithoutComboiosLideradosNestedInput = {
    create?: XOR<UserCreateWithoutComboiosLideradosInput, UserUncheckedCreateWithoutComboiosLideradosInput>
    connectOrCreate?: UserCreateOrConnectWithoutComboiosLideradosInput
    upsert?: UserUpsertWithoutComboiosLideradosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutComboiosLideradosInput, UserUpdateWithoutComboiosLideradosInput>, UserUncheckedUpdateWithoutComboiosLideradosInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FamiliarCreateWithoutUserInput = {
    id?: string
    nome: string
    parentesco: string
    idade?: number | null
    telefone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamiliarUncheckedCreateWithoutUserInput = {
    id?: string
    nome: string
    parentesco: string
    idade?: number | null
    telefone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamiliarCreateOrConnectWithoutUserInput = {
    where: FamiliarWhereUniqueInput
    create: XOR<FamiliarCreateWithoutUserInput, FamiliarUncheckedCreateWithoutUserInput>
  }

  export type FamiliarCreateManyUserInputEnvelope = {
    data: FamiliarCreateManyUserInput | FamiliarCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PremioCreateWithoutUserInput = {
    id?: string
    titulo: string
    descricao?: string | null
    categoria: string
    ano: number
    posicao?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PremioUncheckedCreateWithoutUserInput = {
    id?: string
    titulo: string
    descricao?: string | null
    categoria: string
    ano: number
    posicao?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PremioCreateOrConnectWithoutUserInput = {
    where: PremioWhereUniqueInput
    create: XOR<PremioCreateWithoutUserInput, PremioUncheckedCreateWithoutUserInput>
  }

  export type PremioCreateManyUserInputEnvelope = {
    data: PremioCreateManyUserInput | PremioCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MotoCreateWithoutUserInput = {
    id?: string
    marca: string
    modelo: string
    ano: number
    cor: string
    cilindrada: string
    placa?: string | null
    principal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MotoUncheckedCreateWithoutUserInput = {
    id?: string
    marca: string
    modelo: string
    ano: number
    cor: string
    cilindrada: string
    placa?: string | null
    principal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MotoCreateOrConnectWithoutUserInput = {
    where: MotoWhereUniqueInput
    create: XOR<MotoCreateWithoutUserInput, MotoUncheckedCreateWithoutUserInput>
  }

  export type MotoCreateManyUserInputEnvelope = {
    data: MotoCreateManyUserInput | MotoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ParticipacaoEventoCreateWithoutUserInput = {
    id?: string
    confirmado?: boolean
    dataConfirmacao?: Date | string | null
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    evento: EventoCreateNestedOneWithoutParticipacoesInput
  }

  export type ParticipacaoEventoUncheckedCreateWithoutUserInput = {
    id?: string
    confirmado?: boolean
    dataConfirmacao?: Date | string | null
    observacoes?: string | null
    eventoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipacaoEventoCreateOrConnectWithoutUserInput = {
    where: ParticipacaoEventoWhereUniqueInput
    create: XOR<ParticipacaoEventoCreateWithoutUserInput, ParticipacaoEventoUncheckedCreateWithoutUserInput>
  }

  export type ParticipacaoEventoCreateManyUserInputEnvelope = {
    data: ParticipacaoEventoCreateManyUserInput | ParticipacaoEventoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ComboioEventoCreateWithoutLiderInput = {
    id?: string
    nome: string
    descricao?: string | null
    pontoEncontro: string
    horarioSaida: Date | string
    vagas?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    evento: EventoCreateNestedOneWithoutComboiosInput
  }

  export type ComboioEventoUncheckedCreateWithoutLiderInput = {
    id?: string
    nome: string
    descricao?: string | null
    pontoEncontro: string
    horarioSaida: Date | string
    vagas?: number
    ativo?: boolean
    eventoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComboioEventoCreateOrConnectWithoutLiderInput = {
    where: ComboioEventoWhereUniqueInput
    create: XOR<ComboioEventoCreateWithoutLiderInput, ComboioEventoUncheckedCreateWithoutLiderInput>
  }

  export type ComboioEventoCreateManyLiderInputEnvelope = {
    data: ComboioEventoCreateManyLiderInput | ComboioEventoCreateManyLiderInput[]
    skipDuplicates?: boolean
  }

  export type FamiliarUpsertWithWhereUniqueWithoutUserInput = {
    where: FamiliarWhereUniqueInput
    update: XOR<FamiliarUpdateWithoutUserInput, FamiliarUncheckedUpdateWithoutUserInput>
    create: XOR<FamiliarCreateWithoutUserInput, FamiliarUncheckedCreateWithoutUserInput>
  }

  export type FamiliarUpdateWithWhereUniqueWithoutUserInput = {
    where: FamiliarWhereUniqueInput
    data: XOR<FamiliarUpdateWithoutUserInput, FamiliarUncheckedUpdateWithoutUserInput>
  }

  export type FamiliarUpdateManyWithWhereWithoutUserInput = {
    where: FamiliarScalarWhereInput
    data: XOR<FamiliarUpdateManyMutationInput, FamiliarUncheckedUpdateManyWithoutUserInput>
  }

  export type FamiliarScalarWhereInput = {
    AND?: FamiliarScalarWhereInput | FamiliarScalarWhereInput[]
    OR?: FamiliarScalarWhereInput[]
    NOT?: FamiliarScalarWhereInput | FamiliarScalarWhereInput[]
    id?: StringFilter<"Familiar"> | string
    nome?: StringFilter<"Familiar"> | string
    parentesco?: StringFilter<"Familiar"> | string
    idade?: IntNullableFilter<"Familiar"> | number | null
    telefone?: StringNullableFilter<"Familiar"> | string | null
    userId?: StringFilter<"Familiar"> | string
    createdAt?: DateTimeFilter<"Familiar"> | Date | string
    updatedAt?: DateTimeFilter<"Familiar"> | Date | string
  }

  export type PremioUpsertWithWhereUniqueWithoutUserInput = {
    where: PremioWhereUniqueInput
    update: XOR<PremioUpdateWithoutUserInput, PremioUncheckedUpdateWithoutUserInput>
    create: XOR<PremioCreateWithoutUserInput, PremioUncheckedCreateWithoutUserInput>
  }

  export type PremioUpdateWithWhereUniqueWithoutUserInput = {
    where: PremioWhereUniqueInput
    data: XOR<PremioUpdateWithoutUserInput, PremioUncheckedUpdateWithoutUserInput>
  }

  export type PremioUpdateManyWithWhereWithoutUserInput = {
    where: PremioScalarWhereInput
    data: XOR<PremioUpdateManyMutationInput, PremioUncheckedUpdateManyWithoutUserInput>
  }

  export type PremioScalarWhereInput = {
    AND?: PremioScalarWhereInput | PremioScalarWhereInput[]
    OR?: PremioScalarWhereInput[]
    NOT?: PremioScalarWhereInput | PremioScalarWhereInput[]
    id?: StringFilter<"Premio"> | string
    titulo?: StringFilter<"Premio"> | string
    descricao?: StringNullableFilter<"Premio"> | string | null
    categoria?: StringFilter<"Premio"> | string
    ano?: IntFilter<"Premio"> | number
    posicao?: StringNullableFilter<"Premio"> | string | null
    userId?: StringFilter<"Premio"> | string
    createdAt?: DateTimeFilter<"Premio"> | Date | string
    updatedAt?: DateTimeFilter<"Premio"> | Date | string
  }

  export type MotoUpsertWithWhereUniqueWithoutUserInput = {
    where: MotoWhereUniqueInput
    update: XOR<MotoUpdateWithoutUserInput, MotoUncheckedUpdateWithoutUserInput>
    create: XOR<MotoCreateWithoutUserInput, MotoUncheckedCreateWithoutUserInput>
  }

  export type MotoUpdateWithWhereUniqueWithoutUserInput = {
    where: MotoWhereUniqueInput
    data: XOR<MotoUpdateWithoutUserInput, MotoUncheckedUpdateWithoutUserInput>
  }

  export type MotoUpdateManyWithWhereWithoutUserInput = {
    where: MotoScalarWhereInput
    data: XOR<MotoUpdateManyMutationInput, MotoUncheckedUpdateManyWithoutUserInput>
  }

  export type MotoScalarWhereInput = {
    AND?: MotoScalarWhereInput | MotoScalarWhereInput[]
    OR?: MotoScalarWhereInput[]
    NOT?: MotoScalarWhereInput | MotoScalarWhereInput[]
    id?: StringFilter<"Moto"> | string
    marca?: StringFilter<"Moto"> | string
    modelo?: StringFilter<"Moto"> | string
    ano?: IntFilter<"Moto"> | number
    cor?: StringFilter<"Moto"> | string
    cilindrada?: StringFilter<"Moto"> | string
    placa?: StringNullableFilter<"Moto"> | string | null
    principal?: BoolFilter<"Moto"> | boolean
    userId?: StringFilter<"Moto"> | string
    createdAt?: DateTimeFilter<"Moto"> | Date | string
    updatedAt?: DateTimeFilter<"Moto"> | Date | string
  }

  export type ParticipacaoEventoUpsertWithWhereUniqueWithoutUserInput = {
    where: ParticipacaoEventoWhereUniqueInput
    update: XOR<ParticipacaoEventoUpdateWithoutUserInput, ParticipacaoEventoUncheckedUpdateWithoutUserInput>
    create: XOR<ParticipacaoEventoCreateWithoutUserInput, ParticipacaoEventoUncheckedCreateWithoutUserInput>
  }

  export type ParticipacaoEventoUpdateWithWhereUniqueWithoutUserInput = {
    where: ParticipacaoEventoWhereUniqueInput
    data: XOR<ParticipacaoEventoUpdateWithoutUserInput, ParticipacaoEventoUncheckedUpdateWithoutUserInput>
  }

  export type ParticipacaoEventoUpdateManyWithWhereWithoutUserInput = {
    where: ParticipacaoEventoScalarWhereInput
    data: XOR<ParticipacaoEventoUpdateManyMutationInput, ParticipacaoEventoUncheckedUpdateManyWithoutUserInput>
  }

  export type ParticipacaoEventoScalarWhereInput = {
    AND?: ParticipacaoEventoScalarWhereInput | ParticipacaoEventoScalarWhereInput[]
    OR?: ParticipacaoEventoScalarWhereInput[]
    NOT?: ParticipacaoEventoScalarWhereInput | ParticipacaoEventoScalarWhereInput[]
    id?: StringFilter<"ParticipacaoEvento"> | string
    confirmado?: BoolFilter<"ParticipacaoEvento"> | boolean
    dataConfirmacao?: DateTimeNullableFilter<"ParticipacaoEvento"> | Date | string | null
    observacoes?: StringNullableFilter<"ParticipacaoEvento"> | string | null
    userId?: StringFilter<"ParticipacaoEvento"> | string
    eventoId?: StringFilter<"ParticipacaoEvento"> | string
    createdAt?: DateTimeFilter<"ParticipacaoEvento"> | Date | string
    updatedAt?: DateTimeFilter<"ParticipacaoEvento"> | Date | string
  }

  export type ComboioEventoUpsertWithWhereUniqueWithoutLiderInput = {
    where: ComboioEventoWhereUniqueInput
    update: XOR<ComboioEventoUpdateWithoutLiderInput, ComboioEventoUncheckedUpdateWithoutLiderInput>
    create: XOR<ComboioEventoCreateWithoutLiderInput, ComboioEventoUncheckedCreateWithoutLiderInput>
  }

  export type ComboioEventoUpdateWithWhereUniqueWithoutLiderInput = {
    where: ComboioEventoWhereUniqueInput
    data: XOR<ComboioEventoUpdateWithoutLiderInput, ComboioEventoUncheckedUpdateWithoutLiderInput>
  }

  export type ComboioEventoUpdateManyWithWhereWithoutLiderInput = {
    where: ComboioEventoScalarWhereInput
    data: XOR<ComboioEventoUpdateManyMutationInput, ComboioEventoUncheckedUpdateManyWithoutLiderInput>
  }

  export type ComboioEventoScalarWhereInput = {
    AND?: ComboioEventoScalarWhereInput | ComboioEventoScalarWhereInput[]
    OR?: ComboioEventoScalarWhereInput[]
    NOT?: ComboioEventoScalarWhereInput | ComboioEventoScalarWhereInput[]
    id?: StringFilter<"ComboioEvento"> | string
    nome?: StringFilter<"ComboioEvento"> | string
    descricao?: StringNullableFilter<"ComboioEvento"> | string | null
    pontoEncontro?: StringFilter<"ComboioEvento"> | string
    horarioSaida?: DateTimeFilter<"ComboioEvento"> | Date | string
    vagas?: IntFilter<"ComboioEvento"> | number
    ativo?: BoolFilter<"ComboioEvento"> | boolean
    eventoId?: StringFilter<"ComboioEvento"> | string
    liderUserId?: StringFilter<"ComboioEvento"> | string
    createdAt?: DateTimeFilter<"ComboioEvento"> | Date | string
    updatedAt?: DateTimeFilter<"ComboioEvento"> | Date | string
  }

  export type UserCreateWithoutFamiliaresInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    premios?: PremioCreateNestedManyWithoutUserInput
    motos?: MotoCreateNestedManyWithoutUserInput
    participacoes?: ParticipacaoEventoCreateNestedManyWithoutUserInput
    comboiosLiderados?: ComboioEventoCreateNestedManyWithoutLiderInput
  }

  export type UserUncheckedCreateWithoutFamiliaresInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    premios?: PremioUncheckedCreateNestedManyWithoutUserInput
    motos?: MotoUncheckedCreateNestedManyWithoutUserInput
    participacoes?: ParticipacaoEventoUncheckedCreateNestedManyWithoutUserInput
    comboiosLiderados?: ComboioEventoUncheckedCreateNestedManyWithoutLiderInput
  }

  export type UserCreateOrConnectWithoutFamiliaresInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFamiliaresInput, UserUncheckedCreateWithoutFamiliaresInput>
  }

  export type UserUpsertWithoutFamiliaresInput = {
    update: XOR<UserUpdateWithoutFamiliaresInput, UserUncheckedUpdateWithoutFamiliaresInput>
    create: XOR<UserCreateWithoutFamiliaresInput, UserUncheckedCreateWithoutFamiliaresInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFamiliaresInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFamiliaresInput, UserUncheckedUpdateWithoutFamiliaresInput>
  }

  export type UserUpdateWithoutFamiliaresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    premios?: PremioUpdateManyWithoutUserNestedInput
    motos?: MotoUpdateManyWithoutUserNestedInput
    participacoes?: ParticipacaoEventoUpdateManyWithoutUserNestedInput
    comboiosLiderados?: ComboioEventoUpdateManyWithoutLiderNestedInput
  }

  export type UserUncheckedUpdateWithoutFamiliaresInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    premios?: PremioUncheckedUpdateManyWithoutUserNestedInput
    motos?: MotoUncheckedUpdateManyWithoutUserNestedInput
    participacoes?: ParticipacaoEventoUncheckedUpdateManyWithoutUserNestedInput
    comboiosLiderados?: ComboioEventoUncheckedUpdateManyWithoutLiderNestedInput
  }

  export type UserCreateWithoutPremiosInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    familiares?: FamiliarCreateNestedManyWithoutUserInput
    motos?: MotoCreateNestedManyWithoutUserInput
    participacoes?: ParticipacaoEventoCreateNestedManyWithoutUserInput
    comboiosLiderados?: ComboioEventoCreateNestedManyWithoutLiderInput
  }

  export type UserUncheckedCreateWithoutPremiosInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    familiares?: FamiliarUncheckedCreateNestedManyWithoutUserInput
    motos?: MotoUncheckedCreateNestedManyWithoutUserInput
    participacoes?: ParticipacaoEventoUncheckedCreateNestedManyWithoutUserInput
    comboiosLiderados?: ComboioEventoUncheckedCreateNestedManyWithoutLiderInput
  }

  export type UserCreateOrConnectWithoutPremiosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPremiosInput, UserUncheckedCreateWithoutPremiosInput>
  }

  export type UserUpsertWithoutPremiosInput = {
    update: XOR<UserUpdateWithoutPremiosInput, UserUncheckedUpdateWithoutPremiosInput>
    create: XOR<UserCreateWithoutPremiosInput, UserUncheckedCreateWithoutPremiosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPremiosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPremiosInput, UserUncheckedUpdateWithoutPremiosInput>
  }

  export type UserUpdateWithoutPremiosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familiares?: FamiliarUpdateManyWithoutUserNestedInput
    motos?: MotoUpdateManyWithoutUserNestedInput
    participacoes?: ParticipacaoEventoUpdateManyWithoutUserNestedInput
    comboiosLiderados?: ComboioEventoUpdateManyWithoutLiderNestedInput
  }

  export type UserUncheckedUpdateWithoutPremiosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familiares?: FamiliarUncheckedUpdateManyWithoutUserNestedInput
    motos?: MotoUncheckedUpdateManyWithoutUserNestedInput
    participacoes?: ParticipacaoEventoUncheckedUpdateManyWithoutUserNestedInput
    comboiosLiderados?: ComboioEventoUncheckedUpdateManyWithoutLiderNestedInput
  }

  export type UserCreateWithoutMotosInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    familiares?: FamiliarCreateNestedManyWithoutUserInput
    premios?: PremioCreateNestedManyWithoutUserInput
    participacoes?: ParticipacaoEventoCreateNestedManyWithoutUserInput
    comboiosLiderados?: ComboioEventoCreateNestedManyWithoutLiderInput
  }

  export type UserUncheckedCreateWithoutMotosInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    familiares?: FamiliarUncheckedCreateNestedManyWithoutUserInput
    premios?: PremioUncheckedCreateNestedManyWithoutUserInput
    participacoes?: ParticipacaoEventoUncheckedCreateNestedManyWithoutUserInput
    comboiosLiderados?: ComboioEventoUncheckedCreateNestedManyWithoutLiderInput
  }

  export type UserCreateOrConnectWithoutMotosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMotosInput, UserUncheckedCreateWithoutMotosInput>
  }

  export type UserUpsertWithoutMotosInput = {
    update: XOR<UserUpdateWithoutMotosInput, UserUncheckedUpdateWithoutMotosInput>
    create: XOR<UserCreateWithoutMotosInput, UserUncheckedCreateWithoutMotosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMotosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMotosInput, UserUncheckedUpdateWithoutMotosInput>
  }

  export type UserUpdateWithoutMotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familiares?: FamiliarUpdateManyWithoutUserNestedInput
    premios?: PremioUpdateManyWithoutUserNestedInput
    participacoes?: ParticipacaoEventoUpdateManyWithoutUserNestedInput
    comboiosLiderados?: ComboioEventoUpdateManyWithoutLiderNestedInput
  }

  export type UserUncheckedUpdateWithoutMotosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familiares?: FamiliarUncheckedUpdateManyWithoutUserNestedInput
    premios?: PremioUncheckedUpdateManyWithoutUserNestedInput
    participacoes?: ParticipacaoEventoUncheckedUpdateManyWithoutUserNestedInput
    comboiosLiderados?: ComboioEventoUncheckedUpdateManyWithoutLiderNestedInput
  }

  export type ParticipacaoEventoCreateWithoutEventoInput = {
    id?: string
    confirmado?: boolean
    dataConfirmacao?: Date | string | null
    observacoes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutParticipacoesInput
  }

  export type ParticipacaoEventoUncheckedCreateWithoutEventoInput = {
    id?: string
    confirmado?: boolean
    dataConfirmacao?: Date | string | null
    observacoes?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipacaoEventoCreateOrConnectWithoutEventoInput = {
    where: ParticipacaoEventoWhereUniqueInput
    create: XOR<ParticipacaoEventoCreateWithoutEventoInput, ParticipacaoEventoUncheckedCreateWithoutEventoInput>
  }

  export type ParticipacaoEventoCreateManyEventoInputEnvelope = {
    data: ParticipacaoEventoCreateManyEventoInput | ParticipacaoEventoCreateManyEventoInput[]
    skipDuplicates?: boolean
  }

  export type ComboioEventoCreateWithoutEventoInput = {
    id?: string
    nome: string
    descricao?: string | null
    pontoEncontro: string
    horarioSaida: Date | string
    vagas?: number
    ativo?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    lider: UserCreateNestedOneWithoutComboiosLideradosInput
  }

  export type ComboioEventoUncheckedCreateWithoutEventoInput = {
    id?: string
    nome: string
    descricao?: string | null
    pontoEncontro: string
    horarioSaida: Date | string
    vagas?: number
    ativo?: boolean
    liderUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComboioEventoCreateOrConnectWithoutEventoInput = {
    where: ComboioEventoWhereUniqueInput
    create: XOR<ComboioEventoCreateWithoutEventoInput, ComboioEventoUncheckedCreateWithoutEventoInput>
  }

  export type ComboioEventoCreateManyEventoInputEnvelope = {
    data: ComboioEventoCreateManyEventoInput | ComboioEventoCreateManyEventoInput[]
    skipDuplicates?: boolean
  }

  export type ParticipacaoEventoUpsertWithWhereUniqueWithoutEventoInput = {
    where: ParticipacaoEventoWhereUniqueInput
    update: XOR<ParticipacaoEventoUpdateWithoutEventoInput, ParticipacaoEventoUncheckedUpdateWithoutEventoInput>
    create: XOR<ParticipacaoEventoCreateWithoutEventoInput, ParticipacaoEventoUncheckedCreateWithoutEventoInput>
  }

  export type ParticipacaoEventoUpdateWithWhereUniqueWithoutEventoInput = {
    where: ParticipacaoEventoWhereUniqueInput
    data: XOR<ParticipacaoEventoUpdateWithoutEventoInput, ParticipacaoEventoUncheckedUpdateWithoutEventoInput>
  }

  export type ParticipacaoEventoUpdateManyWithWhereWithoutEventoInput = {
    where: ParticipacaoEventoScalarWhereInput
    data: XOR<ParticipacaoEventoUpdateManyMutationInput, ParticipacaoEventoUncheckedUpdateManyWithoutEventoInput>
  }

  export type ComboioEventoUpsertWithWhereUniqueWithoutEventoInput = {
    where: ComboioEventoWhereUniqueInput
    update: XOR<ComboioEventoUpdateWithoutEventoInput, ComboioEventoUncheckedUpdateWithoutEventoInput>
    create: XOR<ComboioEventoCreateWithoutEventoInput, ComboioEventoUncheckedCreateWithoutEventoInput>
  }

  export type ComboioEventoUpdateWithWhereUniqueWithoutEventoInput = {
    where: ComboioEventoWhereUniqueInput
    data: XOR<ComboioEventoUpdateWithoutEventoInput, ComboioEventoUncheckedUpdateWithoutEventoInput>
  }

  export type ComboioEventoUpdateManyWithWhereWithoutEventoInput = {
    where: ComboioEventoScalarWhereInput
    data: XOR<ComboioEventoUpdateManyMutationInput, ComboioEventoUncheckedUpdateManyWithoutEventoInput>
  }

  export type UserCreateWithoutParticipacoesInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    familiares?: FamiliarCreateNestedManyWithoutUserInput
    premios?: PremioCreateNestedManyWithoutUserInput
    motos?: MotoCreateNestedManyWithoutUserInput
    comboiosLiderados?: ComboioEventoCreateNestedManyWithoutLiderInput
  }

  export type UserUncheckedCreateWithoutParticipacoesInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    familiares?: FamiliarUncheckedCreateNestedManyWithoutUserInput
    premios?: PremioUncheckedCreateNestedManyWithoutUserInput
    motos?: MotoUncheckedCreateNestedManyWithoutUserInput
    comboiosLiderados?: ComboioEventoUncheckedCreateNestedManyWithoutLiderInput
  }

  export type UserCreateOrConnectWithoutParticipacoesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutParticipacoesInput, UserUncheckedCreateWithoutParticipacoesInput>
  }

  export type EventoCreateWithoutParticipacoesInput = {
    id?: string
    titulo: string
    descricao: string
    dataEvento: Date | string
    localEvento: string
    endereco: string
    latitude?: number | null
    longitude?: number | null
    participantesMaximo?: number | null
    valorInscricao?: number | null
    ativo?: boolean
    imagemUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comboios?: ComboioEventoCreateNestedManyWithoutEventoInput
  }

  export type EventoUncheckedCreateWithoutParticipacoesInput = {
    id?: string
    titulo: string
    descricao: string
    dataEvento: Date | string
    localEvento: string
    endereco: string
    latitude?: number | null
    longitude?: number | null
    participantesMaximo?: number | null
    valorInscricao?: number | null
    ativo?: boolean
    imagemUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comboios?: ComboioEventoUncheckedCreateNestedManyWithoutEventoInput
  }

  export type EventoCreateOrConnectWithoutParticipacoesInput = {
    where: EventoWhereUniqueInput
    create: XOR<EventoCreateWithoutParticipacoesInput, EventoUncheckedCreateWithoutParticipacoesInput>
  }

  export type UserUpsertWithoutParticipacoesInput = {
    update: XOR<UserUpdateWithoutParticipacoesInput, UserUncheckedUpdateWithoutParticipacoesInput>
    create: XOR<UserCreateWithoutParticipacoesInput, UserUncheckedCreateWithoutParticipacoesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutParticipacoesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutParticipacoesInput, UserUncheckedUpdateWithoutParticipacoesInput>
  }

  export type UserUpdateWithoutParticipacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familiares?: FamiliarUpdateManyWithoutUserNestedInput
    premios?: PremioUpdateManyWithoutUserNestedInput
    motos?: MotoUpdateManyWithoutUserNestedInput
    comboiosLiderados?: ComboioEventoUpdateManyWithoutLiderNestedInput
  }

  export type UserUncheckedUpdateWithoutParticipacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familiares?: FamiliarUncheckedUpdateManyWithoutUserNestedInput
    premios?: PremioUncheckedUpdateManyWithoutUserNestedInput
    motos?: MotoUncheckedUpdateManyWithoutUserNestedInput
    comboiosLiderados?: ComboioEventoUncheckedUpdateManyWithoutLiderNestedInput
  }

  export type EventoUpsertWithoutParticipacoesInput = {
    update: XOR<EventoUpdateWithoutParticipacoesInput, EventoUncheckedUpdateWithoutParticipacoesInput>
    create: XOR<EventoCreateWithoutParticipacoesInput, EventoUncheckedCreateWithoutParticipacoesInput>
    where?: EventoWhereInput
  }

  export type EventoUpdateToOneWithWhereWithoutParticipacoesInput = {
    where?: EventoWhereInput
    data: XOR<EventoUpdateWithoutParticipacoesInput, EventoUncheckedUpdateWithoutParticipacoesInput>
  }

  export type EventoUpdateWithoutParticipacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataEvento?: DateTimeFieldUpdateOperationsInput | Date | string
    localEvento?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    participantesMaximo?: NullableIntFieldUpdateOperationsInput | number | null
    valorInscricao?: NullableFloatFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    imagemUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comboios?: ComboioEventoUpdateManyWithoutEventoNestedInput
  }

  export type EventoUncheckedUpdateWithoutParticipacoesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataEvento?: DateTimeFieldUpdateOperationsInput | Date | string
    localEvento?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    participantesMaximo?: NullableIntFieldUpdateOperationsInput | number | null
    valorInscricao?: NullableFloatFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    imagemUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comboios?: ComboioEventoUncheckedUpdateManyWithoutEventoNestedInput
  }

  export type EventoCreateWithoutComboiosInput = {
    id?: string
    titulo: string
    descricao: string
    dataEvento: Date | string
    localEvento: string
    endereco: string
    latitude?: number | null
    longitude?: number | null
    participantesMaximo?: number | null
    valorInscricao?: number | null
    ativo?: boolean
    imagemUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participacoes?: ParticipacaoEventoCreateNestedManyWithoutEventoInput
  }

  export type EventoUncheckedCreateWithoutComboiosInput = {
    id?: string
    titulo: string
    descricao: string
    dataEvento: Date | string
    localEvento: string
    endereco: string
    latitude?: number | null
    longitude?: number | null
    participantesMaximo?: number | null
    valorInscricao?: number | null
    ativo?: boolean
    imagemUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    participacoes?: ParticipacaoEventoUncheckedCreateNestedManyWithoutEventoInput
  }

  export type EventoCreateOrConnectWithoutComboiosInput = {
    where: EventoWhereUniqueInput
    create: XOR<EventoCreateWithoutComboiosInput, EventoUncheckedCreateWithoutComboiosInput>
  }

  export type UserCreateWithoutComboiosLideradosInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    familiares?: FamiliarCreateNestedManyWithoutUserInput
    premios?: PremioCreateNestedManyWithoutUserInput
    motos?: MotoCreateNestedManyWithoutUserInput
    participacoes?: ParticipacaoEventoCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutComboiosLideradosInput = {
    id?: string
    email: string
    password: string
    nomeCompleto: string
    telefone?: string | null
    cidade?: string | null
    estado?: string | null
    dataNascimento?: Date | string | null
    tipoUsuario?: $Enums.UserType
    ativo?: boolean
    emailVerificado?: boolean
    avatarUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    familiares?: FamiliarUncheckedCreateNestedManyWithoutUserInput
    premios?: PremioUncheckedCreateNestedManyWithoutUserInput
    motos?: MotoUncheckedCreateNestedManyWithoutUserInput
    participacoes?: ParticipacaoEventoUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutComboiosLideradosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutComboiosLideradosInput, UserUncheckedCreateWithoutComboiosLideradosInput>
  }

  export type EventoUpsertWithoutComboiosInput = {
    update: XOR<EventoUpdateWithoutComboiosInput, EventoUncheckedUpdateWithoutComboiosInput>
    create: XOR<EventoCreateWithoutComboiosInput, EventoUncheckedCreateWithoutComboiosInput>
    where?: EventoWhereInput
  }

  export type EventoUpdateToOneWithWhereWithoutComboiosInput = {
    where?: EventoWhereInput
    data: XOR<EventoUpdateWithoutComboiosInput, EventoUncheckedUpdateWithoutComboiosInput>
  }

  export type EventoUpdateWithoutComboiosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataEvento?: DateTimeFieldUpdateOperationsInput | Date | string
    localEvento?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    participantesMaximo?: NullableIntFieldUpdateOperationsInput | number | null
    valorInscricao?: NullableFloatFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    imagemUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participacoes?: ParticipacaoEventoUpdateManyWithoutEventoNestedInput
  }

  export type EventoUncheckedUpdateWithoutComboiosInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: StringFieldUpdateOperationsInput | string
    dataEvento?: DateTimeFieldUpdateOperationsInput | Date | string
    localEvento?: StringFieldUpdateOperationsInput | string
    endereco?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    participantesMaximo?: NullableIntFieldUpdateOperationsInput | number | null
    valorInscricao?: NullableFloatFieldUpdateOperationsInput | number | null
    ativo?: BoolFieldUpdateOperationsInput | boolean
    imagemUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participacoes?: ParticipacaoEventoUncheckedUpdateManyWithoutEventoNestedInput
  }

  export type UserUpsertWithoutComboiosLideradosInput = {
    update: XOR<UserUpdateWithoutComboiosLideradosInput, UserUncheckedUpdateWithoutComboiosLideradosInput>
    create: XOR<UserCreateWithoutComboiosLideradosInput, UserUncheckedCreateWithoutComboiosLideradosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutComboiosLideradosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutComboiosLideradosInput, UserUncheckedUpdateWithoutComboiosLideradosInput>
  }

  export type UserUpdateWithoutComboiosLideradosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familiares?: FamiliarUpdateManyWithoutUserNestedInput
    premios?: PremioUpdateManyWithoutUserNestedInput
    motos?: MotoUpdateManyWithoutUserNestedInput
    participacoes?: ParticipacaoEventoUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutComboiosLideradosInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    nomeCompleto?: StringFieldUpdateOperationsInput | string
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    cidade?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: NullableStringFieldUpdateOperationsInput | string | null
    dataNascimento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tipoUsuario?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    ativo?: BoolFieldUpdateOperationsInput | boolean
    emailVerificado?: BoolFieldUpdateOperationsInput | boolean
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    familiares?: FamiliarUncheckedUpdateManyWithoutUserNestedInput
    premios?: PremioUncheckedUpdateManyWithoutUserNestedInput
    motos?: MotoUncheckedUpdateManyWithoutUserNestedInput
    participacoes?: ParticipacaoEventoUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FamiliarCreateManyUserInput = {
    id?: string
    nome: string
    parentesco: string
    idade?: number | null
    telefone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PremioCreateManyUserInput = {
    id?: string
    titulo: string
    descricao?: string | null
    categoria: string
    ano: number
    posicao?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MotoCreateManyUserInput = {
    id?: string
    marca: string
    modelo: string
    ano: number
    cor: string
    cilindrada: string
    placa?: string | null
    principal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipacaoEventoCreateManyUserInput = {
    id?: string
    confirmado?: boolean
    dataConfirmacao?: Date | string | null
    observacoes?: string | null
    eventoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComboioEventoCreateManyLiderInput = {
    id?: string
    nome: string
    descricao?: string | null
    pontoEncontro: string
    horarioSaida: Date | string
    vagas?: number
    ativo?: boolean
    eventoId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FamiliarUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    parentesco?: StringFieldUpdateOperationsInput | string
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamiliarUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    parentesco?: StringFieldUpdateOperationsInput | string
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FamiliarUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    parentesco?: StringFieldUpdateOperationsInput | string
    idade?: NullableIntFieldUpdateOperationsInput | number | null
    telefone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PremioUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    posicao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PremioUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    posicao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PremioUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    titulo?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    categoria?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    posicao?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    cor?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    cor?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MotoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    marca?: StringFieldUpdateOperationsInput | string
    modelo?: StringFieldUpdateOperationsInput | string
    ano?: IntFieldUpdateOperationsInput | number
    cor?: StringFieldUpdateOperationsInput | string
    cilindrada?: StringFieldUpdateOperationsInput | string
    placa?: NullableStringFieldUpdateOperationsInput | string | null
    principal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipacaoEventoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    dataConfirmacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evento?: EventoUpdateOneRequiredWithoutParticipacoesNestedInput
  }

  export type ParticipacaoEventoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    dataConfirmacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    eventoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipacaoEventoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    dataConfirmacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    eventoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComboioEventoUpdateWithoutLiderInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    pontoEncontro?: StringFieldUpdateOperationsInput | string
    horarioSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    vagas?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evento?: EventoUpdateOneRequiredWithoutComboiosNestedInput
  }

  export type ComboioEventoUncheckedUpdateWithoutLiderInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    pontoEncontro?: StringFieldUpdateOperationsInput | string
    horarioSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    vagas?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    eventoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComboioEventoUncheckedUpdateManyWithoutLiderInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    pontoEncontro?: StringFieldUpdateOperationsInput | string
    horarioSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    vagas?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    eventoId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipacaoEventoCreateManyEventoInput = {
    id?: string
    confirmado?: boolean
    dataConfirmacao?: Date | string | null
    observacoes?: string | null
    userId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComboioEventoCreateManyEventoInput = {
    id?: string
    nome: string
    descricao?: string | null
    pontoEncontro: string
    horarioSaida: Date | string
    vagas?: number
    ativo?: boolean
    liderUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ParticipacaoEventoUpdateWithoutEventoInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    dataConfirmacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutParticipacoesNestedInput
  }

  export type ParticipacaoEventoUncheckedUpdateWithoutEventoInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    dataConfirmacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipacaoEventoUncheckedUpdateManyWithoutEventoInput = {
    id?: StringFieldUpdateOperationsInput | string
    confirmado?: BoolFieldUpdateOperationsInput | boolean
    dataConfirmacao?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    observacoes?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComboioEventoUpdateWithoutEventoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    pontoEncontro?: StringFieldUpdateOperationsInput | string
    horarioSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    vagas?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lider?: UserUpdateOneRequiredWithoutComboiosLideradosNestedInput
  }

  export type ComboioEventoUncheckedUpdateWithoutEventoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    pontoEncontro?: StringFieldUpdateOperationsInput | string
    horarioSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    vagas?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    liderUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComboioEventoUncheckedUpdateManyWithoutEventoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nome?: StringFieldUpdateOperationsInput | string
    descricao?: NullableStringFieldUpdateOperationsInput | string | null
    pontoEncontro?: StringFieldUpdateOperationsInput | string
    horarioSaida?: DateTimeFieldUpdateOperationsInput | Date | string
    vagas?: IntFieldUpdateOperationsInput | number
    ativo?: BoolFieldUpdateOperationsInput | boolean
    liderUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventoCountOutputTypeDefaultArgs instead
     */
    export type EventoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FamiliarDefaultArgs instead
     */
    export type FamiliarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FamiliarDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PremioDefaultArgs instead
     */
    export type PremioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PremioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MotoDefaultArgs instead
     */
    export type MotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MotoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventoDefaultArgs instead
     */
    export type EventoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ParticipacaoEventoDefaultArgs instead
     */
    export type ParticipacaoEventoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ParticipacaoEventoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ComboioEventoDefaultArgs instead
     */
    export type ComboioEventoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ComboioEventoDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}